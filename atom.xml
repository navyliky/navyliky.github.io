<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Navy的荒岛</title>
  
  <subtitle>世界既不黑也不白，而是一道精致的灰</subtitle>
  <link href="https://navyliky.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://navyliky.github.io.git/"/>
  <updated>2024-06-29T14:39:59.834Z</updated>
  <id>https://navyliky.github.io.git/</id>
  
  <author>
    <name>Navy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态查找</title>
    <link href="https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/"/>
    <id>https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/</id>
    <published>2024-06-29T13:40:00.000Z</published>
    <updated>2024-06-29T14:39:59.834Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>不要去欺骗别人——因为你能骗到的，都是相信你的人</strong></em></p><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p> 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；而是查找失败。</p><p> 查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种：</p><p>1.查询某个特定的数据元素是否在查找表中；</p><p>2.检索满足条件的某个特定的数据元素的各种属性；</p><p>3.在查找表中插入一个数据元素；</p><p>4.从查找表中删除某个数据元素；</p><p>静态查找表：若一个查找表的操作只涉及上述操作的1和2，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态的插入或删除的查找表称为动态查找表。适合静态查找表的的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和B树都是二叉排序树的改进。</p><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中 “学号” 这一数据项的值唯一地标识一名学生。</p><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p> 顺序查找又称为线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过 next 指针来依次扫描每个元素。顺序查找通常分为对一般的<strong>无序线性表</strong>的顺序查找和对按<strong>关键字有序</strong>的线性表的顺序查找。</p><h4 id="线性表的顺序查找"><a href="#线性表的顺序查找" class="headerlink" title="线性表的顺序查找"></a>线性表的顺序查找</h4><p> 这里是无序线性表的顺序查找，基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]==key)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">a[<span class="number">0</span>]=key;</span><br><span class="line">i=n;</span><br><span class="line"><span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环的时候，我们都要判断i是否小于等于n，也就是无哨兵，这里就浪费了效率，所以我们就设置了一个哨兵，通常都是数组的第一个元素，将key赋值给它，然后i就从最大的开始每次都-1，这里就不需要再判断了，因为就算没有找到，循环遇到数组的第一个元素也会跳出，这里就会提高一些效率。</p><p>查找最好的情况就是第一次就找到了，时间复杂度为O(1),最坏的情况是直到最后一个才找到，时间复杂度为O(n),取平均情况就为O((n+1)&#x2F;2),所以这个算法的最终时间复杂度就为O(n)。</p><h4 id="线性表的折半查找"><a href="#线性表的折半查找" class="headerlink" title="线性表的折半查找"></a>线性表的折半查找</h4><p>这里是有序的线性表查找，基本思想是首先将给定值 key 与表中<em><strong>中间位置</strong></em>的元素进行比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;<span class="comment">/* 折半 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以把它看作是具有n个节点的完全二叉树，深度就为log2(n)+1,最好的情况就是第一次就找到了，最坏的情况跟这颗二叉树的深度有关，所以这个算法的时间复杂度就为logn,相比较于顺序查找，效率还是快很多。</p><h4 id="线性表的插值查找"><a href="#线性表的插值查找" class="headerlink" title="线性表的插值查找"></a>线性表的插值查找</h4><p>我们在查字典时，如果需要查找的是cook，就会从前面开始翻找，如果查找的是zoo，就会从后面开始翻找，所以对折半查找进行优化，我们不必每次都从中间开始找，而是按照比例（c字母在26个字母是前三个，假如这个字典，是2600页，那么你要查找的区间大概率为前三百页），当然这个算法只用于比较均匀的数据（说了是大概率），如果不均匀，那么这个算法就毫无优势。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Interpolation_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性表的斐波那契查找"><a href="#线性表的斐波那契查找" class="headerlink" title="线性表的斐波那契查找"></a>线性表的斐波那契查找</h4><p>基本思想 这个想法是首先找到大于或等于给定数组长度的最小斐波那契数。令找到的斐波那契数为 fib（第 m 个斐波那契数）。我们使用第 (m-2) 个斐波那契数作为索引（如果它是有效索引）。设第(m-2)个斐波那契数为i，我们将arr[i]与x进行比较，如果x相同，则返回i。否则，如果 x 更大，则对 i 之后的子数组进行递归，否则对 i 之前的子数组进行递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">a[i]=a[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">k=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">k=k<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>组播广播</title>
    <link href="https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/"/>
    <id>https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/</id>
    <published>2024-03-22T13:40:00.000Z</published>
    <updated>2024-06-29T14:40:51.883Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>如果说调试（debug）是去除 bug 的过程，那么编程就是制造 bug 的过程。<br>——Edsger Dijkstra （图灵奖得主）</strong></em></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 三种IP地址：单播地址、广播地址和组播地址。广播和多播仅应用于UDP（因为TCP是端对端的连接，无法实现一对多）。</p><p>单播，一对一，目的地址是单个主机；</p><p>广播，一对全部，目的地址是局域网中的全部主机；</p><p>多播，一对部分，目的地址是局域网中的部分主机；广播也是多播的一种特殊形式，即目的地址为全部主机。</p><p>TCP是一个面向连接的协议，TCP一定是点对点的，一点是两个主机来建立连接的，TCP肯定是单播。只有UDP才会使用广播和组播。</p><p>有时一个主机要向网上的所有其它主机发送帧，这就是广播，广播分为二层广播（目的MAC全F）和三层广播（IP地址的主机位全1），二层广播是不能跨路由器的，三层广播是可以跨路由器路由的。</p><p>多播属于单播和广播之间，帧仅传送给属于多播组的多个主机。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播的例子随处可见，比如说把屏幕共享给很多人，其实也是广播，首先把屏幕截图，然后广播给所有的客户端，比如说屏幕共享软件，一般都有一个广播地址，只要在同一个网段的客户端都能收到广播，如果设置广播地址为255.255.255.255，那么不管哪个网段都能收到广播。屏幕共享软件会把当前屏幕截图并分为很多小块，然后压缩，广播给所有客户端，客户端再进行解压。</p><p> 广播地址：<br>子网广播地址：x.x.x.255 (主机号全部为1)的地址，我们称为广播地址</p><p>192.168.31.105<br>255.255.255.0<br>网段号 &#x3D; IP &amp; netmask &#x3D; 192.168.31<br>广播地址： 192.168.31.255<br>255.255.255.255 全网广播地址<br>很多路由器设置：禁止全网广播<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》很有可能造成网络风暴<br>广播的工作过程：<br>广播发送者：<br>socket<br>使能广播功能 setsockopt<br>sendto<br>广播接收者：<br>socket<br>使能广播功能 setsockopt<br>bind x.x.x.255 + 端口号<br>recvfrom</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">broadcast_onoff</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (<span class="type">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt SO_BOARDCAST error:&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h2><p>(1) 多播也只有对传输协议为 UDP才支持<br>(2) 多播地址 IP地址 D类地址<br>224.0.0.0 —- 239.255.255.255<br>(3) 广播式发送，占用大量的带宽，造成广播风暴<br>多播是一种折中方式，只有加入 某个多播组才能收到信息<br>（4） 多播编程思路：<br>多播发送者：<br>socket<br>sendto : D类地址 + 端口号<br>……<br>recvfrom<br>多播接收者：<br>socket<br>加入多播组<br>bind: D类地址+port<br>recvfrom<br>如何加入多播组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line">inet_aton(<span class="string">&quot;224.0.0.1&quot;</span>, &amp;mreq.imr_multiaddr); <span class="comment">//D类地址</span></span><br><span class="line">mreq.imr_interface.s_addr = INADDR_ANY; <span class="comment">//由内核找个合适网卡IP</span></span><br><span class="line"><span class="comment">//加入多播组：</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="type">void</span> *)&amp;mreq, sizeo</span><br><span class="line">f(mreq));</span><br></pre></td></tr></table></figure><p>struct ip_mreq {<br>struct in_addr imr_multiaddr; &#x2F;* IP multicast address of<br>group <em>&#x2F;<br>struct in_addr imr_interface; &#x2F;</em> local IP address of<br>interface *&#x2F;<br>};<br>imr_multiaddr： 多播组地址，D类地址，逻辑上的组号，用来<br>区分不同的多播组，<br>但是这个逻辑上的地址，在真正收发数据的时<br>候，一定要依赖真正的网卡<br>这种接口<br>imr_interface： 接口地址</p>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(二)</title>
    <link href="https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/"/>
    <id>https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/</id>
    <published>2024-01-28T13:40:00.000Z</published>
    <updated>2024-06-29T14:42:55.698Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>许多人所谓的成熟，不过是被习俗磨去了棱角，变得世故而实际了；那不是成熟，而是精神的早衰和个性的夭亡！<br>真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。<br>——《在世纪的转折点上》尼采 （哲学家 思想家）</strong></em></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>1） for 语句语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号的内容是用来描述控制循环的变量的变化过程。</p><ol><li>循环变量的初始化 i&#x3D;1；</li><li>循环结束的条件(逻辑表达式，为真继续循环，为假结束循环) i&lt;100;</li><li>每次循环对循环变量的操作 i++</li><li>要循环的语句<br>他是按照这个顺序执行： {1,2},{4,3,2},{4,3,2},{4,3,2},,{4,3,2},{4,3,2},<br>正常情况下(没有break)： 正常结束<br>continue; 在循环中碰到这个continue,跳过下面的语句，重新开始下一次循环<br>循环嵌套——- 有多层循环</li></ol>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(一)</title>
    <link href="https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/"/>
    <id>https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/</id>
    <published>2024-01-27T13:40:00.000Z</published>
    <updated>2024-06-29T14:42:58.220Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>最多人走的路肯定最安全<br>但别指望会在这样的路上碰到很多猎物<br>——纪德 （作家 诺贝尔奖得主)</strong></em></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者将把C语言的知识要点，学习心得以博客形式发表，希望通过这种形式督促自身的学习，也能在这里与大家共同进步，早日成为大牛！</p><p>本系列（初始C语言）只是简单介绍每个知识点、C语言的基础知识，意在使读者（还有自己）大概了解C语言。</p><h2 id="初始C语言"><a href="#初始C语言" class="headerlink" title="初始C语言"></a>初始C语言</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//字符数据类型//就是不是数字的字符</span></span><br><span class="line"><span class="type">short</span><span class="comment">//短整型//就是数字小（绝对值）的整数，很少用</span></span><br><span class="line"><span class="type">int</span> <span class="comment">//整型//就是整数</span></span><br><span class="line"><span class="type">long</span><span class="comment">//长整型//就是数字（绝对值）大的整数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span><span class="comment">//更长的整型//很少用</span></span><br><span class="line"><span class="type">float</span><span class="comment">//单精度浮点数//就是小数</span></span><br><span class="line"><span class="type">double</span><span class="comment">//双精度浮点数//小数位数多的小数</span></span><br></pre></td></tr></table></figure><p>分这么多数据类型的原因：不同数据类型在内存中所占大小是不一样的，如果用大小的盒子装蛋糕，蛋糕有大有小，难免造成空间的浪费，所以人们规定了不同的数据类型，以便空间被物尽其用。</p><h3 id="字符类型—char"><a href="#字符类型—char" class="headerlink" title="字符类型—char"></a>字符类型—char</h3><p>字符类型是一种数据类型，包含256个不同的字符数据,字符数据类型的范围是 -128 - 127(-2^7—2^7-1)<br>在内存中占一个字节（Byte）,在C语言中要使用单引号包含起来，’a’ ‘1’ ‘+’,它也是一个关键字，字符数据也可以用数字表示，字符数据有两种的身份，字符身份和数字身份，字符身份和数字身份的对应关系由ASCII码表定义：<br>man ascii ———- 查看ascii表<br>‘a’ ————– 97<br>‘1’ ————– 49<br>‘+’ ————— 43<br><strong>BIN</strong>: 2进制 ， 只有0和1，两种数组的数据，计算机只认识二进制： 逢2进1。<br>101010 —&gt; 2^5+2^3+2^1 &#x3D; 32+8+2 &#x3D; 42<br><strong>OCT</strong> : 8进制 ， 是以0开头的，逢8进1。<br>027 —-&gt; 2<em>8+7 &#x3D; 23<br>0123 —-&gt; 1</em>8^2+2<em>8^1 + 3</em>8^0 &#x3D; 64 + 16 + 3 &#x3D; 83<br>使用占位符%o将数字的8进制形式打印出来<br><strong>DEC</strong>：10进制<br><strong>HEX</strong>： 16进制 : 0x 开头表示 16进制 ,逢16进1<br>0x27 —-&gt; 2<em>16^1 + 7</em>16^0 &#x3D; 32+7 &#x3D; 39<br>0x123 —&gt;1<em>16^2+2</em>16^1 + 3 *16^0 &#x3D; 256 + 32 + 3 &#x3D;291<br>使用占位符%x %X打印数字的16进制形式<br>十进制 转换为 二进制 ： 134<br>方法1：<br>把十进制数字拆分成多个2的整数次方之和，然后把每个拆分结果单独转换成二进制，随后把所有的结果合并<br>179 &#x3D; 128 + 32 + 16 + 2 + 1<br>&#x3D; 2^7 + 2^5 + 2^4 + 2^1 + 2^0<br>&#x3D; 10110011<br>方法2：把十进制数组不停地除以2直到结果为0，然后把所有的余数倒着写就是对应的二进制数<br>134 0<br>67 1<br>33 1<br>16 0<br>8 0<br>4 0<br>2 0<br>1 1<br>0<br>10000110<br>使用以上方法得到的是对应数字二进制的 <em><strong>原码</strong></em><br>计算机中实际上保存的是二进制的 <em><strong>补码</strong></em><br>所有非负数的补码就是原码 134 –&gt; （原码，补码 ）<br>10000110<br><strong>负数的补码等于原码取反加1</strong> ： -6<br>-6 ： 1000000000000000000000000000110 —</p><blockquote><p>11111111111111111111111010<br>计算机保存有符号的数据时，最高位是符号位，0表示正数，1表示负数<br>使用printf打印字符变量时，使用%d打印数字，使用%c打印字符<br>0-127范围内字符身份和数字身份的对应关系是固定的，所有的计算机都一样<br>‘\n’ —————– 换行符<br>‘\r’ —————– 移动光标到行首<br>‘\t’—————— 制表符<br>‘\b’—————— 退格键<br>‘ “ \在打印时需要转义 —————- &quot; &#39; \<br>ascii表中，数字，大写字母，小写字母是连续的<br>‘b’ - ‘a’ &#x3D; ‘B’ - ‘A’<br>‘g’ - ‘d’ &#x3D; ‘3’ - ‘0</p></blockquote><h3 id="字符类型—无符号字符类型-没有负数-unsigned-char"><a href="#字符类型—无符号字符类型-没有负数-unsigned-char" class="headerlink" title="字符类型—无符号字符类型 (没有负数) unsigned char"></a>字符类型—无符号字符类型 (没有负数) unsigned char</h3><p>范围0-255，同样包含256个不同的字符<br>其他性质和char类型相同</p><h3 id="字符类型—短整型-short-int"><a href="#字符类型—短整型-short-int" class="headerlink" title="字符类型—短整型 short int"></a>字符类型—短整型 short int</h3><p>16位： 2^16次方,短整型包含65536个不同的整数，范围从-32768 - 32767<br>类型名short,占用内存2个字节<br>对应的占位符是%hd —-&gt; half d</p><h3 id="字符类型—整型-int"><a href="#字符类型—整型-int" class="headerlink" title="字符类型—整型 int"></a>字符类型—整型 int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名int,占用内存4个字节<br>对应的占位符%d</p><h3 id="字符类型—无符号整型-unsigned-int"><a href="#字符类型—无符号整型-unsigned-int" class="headerlink" title="字符类型—无符号整型 unsigned int"></a>字符类型—无符号整型 unsigned int</h3><p>范围 0 - 2^32-1<br>占位符%u<br>注:类型名中int可以省略<br>其他性质和int相同</p><h3 id="字符类型—长整型-long-long-int"><a href="#字符类型—长整型-long-long-int" class="headerlink" title="字符类型—长整型 long&#x2F;long int"></a>字符类型—长整型 long&#x2F;long int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名long,占用内存4个字节<br>对应的占位符%ld</p><h3 id="字符类型—无符号长整型-unsigned-long-unsigned-long-int"><a href="#字符类型—无符号长整型-unsigned-long-unsigned-long-int" class="headerlink" title="字符类型—无符号长整型 unsigned long&#x2F;unsigned long int"></a>字符类型—无符号长整型 unsigned long&#x2F;unsigned long int</h3><p>范围 0 - 2^32-1<br>占位符%lu<br>h—-&gt; half<br>u—-&gt; usigned<br>l —–&gt;long<br>d—–&gt; int</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>计算机使用浮点类型来记录带小数点的数字，浮点类型分为两<br>种：<em><strong>单精度浮点型和双精度浮点型</strong></em><br>单精度浮点型对应的类型名是float,占用4个字节<br>占位符：%f %g (%g不保留小数点后的0)<br>双精度浮点型对应的类型名是double，占用8个字节<br>占位符：%lf %lg<br>计算机中的整数默认是int型，可以在数字后加u表示该数字是无<br>符号整型，比如:8u<br>计算机中的小数默认是double型，可以在数字后加f表示该数字<br>是单精度浮点型，比如：4.1f<br>注：可以使用sizeof获取类型，变量，数字的大小</p>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>个人介绍</title>
    <link href="https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    <id>https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-01-24T12:13:00.000Z</published>
    <updated>2024-06-29T14:41:14.946Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>人的一切痛苦都是源于对自己无能的愤怒<br>——王小波 （作家）</strong></em></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我叫王行杭，英文名navy（在百度上搜索关于颜色的英文当中随便选的一个单词，也作为我最喜欢的单词之一）。对于自己的介绍，实在无病呻吟啰嗦很多，作为芸芸众生的其中之一，没有太值得炫耀的东西，但总的来说，也不算太糟糕。</p><h2 id="喜欢的运动"><a href="#喜欢的运动" class="headerlink" title="喜欢的运动"></a>喜欢的运动</h2><p>小学一直热爱的乒乓球，当时我们学校一共就几个乒乓球桌，为了占位置，可以中饭都不去吃。从初中开始，喜欢上了篮球，直到高一，还参加我们篮球校队的培训，但本人身体天分实在有限。大三又开始天天打台球，看斯诺克</p><h2 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h2><p>本博客基于Hexo，所以首先要了解一下我们搭建博客所要用到的框架。Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到github或者coding等代码管理托管平台，然后别人就可以浏览你的博客网页啦。</p><p>关于做这个博客的目的，我也并不是很清楚，当初就看到了几个大佬的博客，觉得很酷，就在网上看各种教程，最终东拼西凑，成了这个样子，做完之后好像也没写啥东西（我好像就这样，三分钟热情），但时隔几个月，发现这个也能成自己面试时的一个自我介绍的加分项吧，所以写写东西，也算对自己学的东西的总结。</p><h2 id="博客流程"><a href="#博客流程" class="headerlink" title="博客流程"></a>博客流程</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>为了把本地的网页文件上传到github上面去，需要用到工具———Git。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><p>windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version来查看一下版本验证是否安装成功。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p>windows:下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功</p><p>配置环境变量：</p><p>1.增加系统变量可以教’NODE_HOME’，值为nodejs所在文件的地方。</p><p>2.在Win10的用户变量，Path变量中增加两个’%NODE_HOME%\node_cache’和’%NODE_HOME%\node_global’,node_cache、node_global文件自行创建，即可完成。</p><p>添加国内镜像源：<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\MyBlog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。</p><p>定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完后输入hexo -v验证是否安装成功。</p><p>至此hexo就安装完了。</p><p>接下来初始化一下hexo,即初始化我们的网站，进入我们主题根目录Hexo，输入hexo init初始化文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹Hexo目录下有：<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题**<br>_config.yml: 博客的配置文件**</p><p>Hexo常用命令详解<br>$ hexo init 命令用于初始化一个本地文件夹为网站的根目录</p><p>$ hexo generate 可以简写成 hexo g<br>该命令用于生成静态文件</p><p>$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s<br>可以加一些参数<br>-p    选项，指定服务器端口，默认为 4000<br>-i    选项，指定服务器 IP 地址，默认为 0.0.0.0<br>-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p><p>$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d</p><p>$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令</p><h3 id="注册Github账号创建个人仓库"><a href="#注册Github账号创建个人仓库" class="headerlink" title="注册Github账号创建个人仓库"></a>注册Github账号创建个人仓库</h3><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository</p><p>要创建一个和你用户名相同的仓库，后面加.<a href="http://github.io,只有这样,将来要部署到github/">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io,其中xxx就是你注册github的用户名./">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。</a></p><h3 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h3><p>生成SSH添加到GitHub，连接Github与本地。<br>右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。</p><p>在git bash输入ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;</a></p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/navyliky/navyliky.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<a href="http://navyliky.github.io/">http://navyliky.github.io</a> 这个网站看到你的博客了</p>]]></content>
    
    
    <summary type="html">简短的自我介绍</summary>
    
    
    
    <category term="个人" scheme="https://navyliky.github.io.git/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="个人介绍" scheme="https://navyliky.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
