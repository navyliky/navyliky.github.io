<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Navy的荒岛</title>
  
  <subtitle>世界既不黑也不白，而是一道精致的灰</subtitle>
  <link href="https://navyliky.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://navyliky.github.io.git/"/>
  <updated>2024-08-02T15:44:17.864Z</updated>
  <id>https://navyliky.github.io.git/</id>
  
  <author>
    <name>Navy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程--FTP项目</title>
    <link href="https://navyliky.github.io.git/2024/08/02/%E4%BB%8B%E7%BB%8D/%E9%A1%B9%E7%9B%AE/ftp/"/>
    <id>https://navyliky.github.io.git/2024/08/02/%E4%BB%8B%E7%BB%8D/%E9%A1%B9%E7%9B%AE/ftp/</id>
    <published>2024-08-02T13:40:00.000Z</published>
    <updated>2024-08-02T15:44:17.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那时她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格<br>–(奥地利)茨维格《断头王后》</p></blockquote><h2 id="FTP项目介绍"><a href="#FTP项目介绍" class="headerlink" title="FTP项目介绍"></a>FTP项目介绍</h2><p>FTP服务器(File Transfer ProtocolServer)是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。FTP是File Transfer Protoco(文件传输协议)<br>设计并实现了一个基于FTP协议的文件传输系统。系统采用客户端&#x2F;服务器架构，通过FTP协议实现文件的上传、下载、等操作。服务器端提供友好的用户界面和可靠的传输功能，接收客户端指令并对指令作出解析，客户器端能够不断发送请求。具有浏览远程服务端的文件和浏览客户端本地文件，以及客户端对远程服务端文件的上传和下载。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol><li>列表服务器的文件</li><li>列表客户端的文件</li><li>下载服务器的文件</li><li>上传客户端文件到 服务器</li><li>退出</li></ol><h2 id="具体实现代码"><a href="#具体实现代码" class="headerlink" title="具体实现代码"></a>具体实现代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;/* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int init_client()</span><br><span class="line">&#123;</span><br><span class="line">//1. socket </span><br><span class="line">// sockfd 用来绑定的描述符</span><br><span class="line">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">//定义1个 好用的 sockaddr_in</span><br><span class="line">struct sockaddr_in saddr;</span><br><span class="line">socklen_t saddrlen = sizeof(saddr);</span><br><span class="line"></span><br><span class="line">saddr.sin_family = AF_INET; //ipv4</span><br><span class="line">saddr.sin_port  = htons(3001);</span><br><span class="line">saddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">//2. 连接服务器 connect </span><br><span class="line"></span><br><span class="line">if(connect(sockfd, (const struct sockaddr *)&amp;saddr,  saddrlen))</span><br><span class="line">perror(&quot;connect&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return sockfd; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;1. 列表服务器的文件\n&quot;);</span><br><span class="line">printf(&quot;2. 列表客户端的文件\n&quot;);</span><br><span class="line">printf(&quot;3. 下载服务器的文件\n&quot;);</span><br><span class="line">printf(&quot;4. 上传客户端文件到 服务器\n&quot;);</span><br><span class="line">printf(&quot;5. 退出\n&quot;);</span><br><span class="line">int ch;</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;ch);</span><br><span class="line">scanf(&quot;%*[^\n]&quot;);</span><br><span class="line">scanf(&quot;%*c&quot;);</span><br><span class="line">return ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">char buf[100]=&#123;&#125;;</span><br><span class="line">char fbuf[1024];</span><br><span class="line">char cmd[50];</span><br><span class="line">int ch,n,fd;</span><br><span class="line">char *p;</span><br><span class="line"></span><br><span class="line">// 初始化网络</span><br><span class="line">int sockfd = init_client();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">ch = menu();</span><br><span class="line">switch(ch)</span><br><span class="line">&#123;</span><br><span class="line">case 1: //列表服务器的文件</span><br><span class="line">send(sockfd, &quot;ls&quot;, 2, 0 ); </span><br><span class="line">//清空 fbuf  : memset,  bzero</span><br><span class="line">memset(fbuf,0,1024); </span><br><span class="line">//bzero(fbuf,1024);</span><br><span class="line"></span><br><span class="line">//接收 服务器发送来的 文件列表信息</span><br><span class="line">n = recv(sockfd, fbuf, 1024,0);</span><br><span class="line">printf(&quot;%s\n&quot;, fbuf);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">case 2: //列表客户端的文件</span><br><span class="line">system(&quot;ls&quot;);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">case 3: //下载服务器的文件</span><br><span class="line">printf(&quot;请输入要下载的文件:例如:get xxx \n&quot;);</span><br><span class="line">fgets(cmd, sizeof(cmd),stdin); // 从键盘读 </span><br><span class="line">printf(&quot;cmd=%s\n&quot;, cmd);</span><br><span class="line">send(sockfd, cmd, strlen(cmd)-1, 0 ); //  -1 去掉最后的 \n  </span><br><span class="line">p = strtok(cmd, &quot; &quot;);</span><br><span class="line">p = strtok(NULL, &quot; &quot;);</span><br><span class="line">printf(&quot;客户要下载的文件:%s\n&quot;, p);</span><br><span class="line">p[strlen(p)-1]=0;</span><br><span class="line">// 我创建一个文件 写</span><br><span class="line">fd = open(p, O_WRONLY|O_CREAT,0644);</span><br><span class="line">if(fd &lt; 0)</span><br><span class="line">perror(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">n = recv(sockfd, fbuf,sizeof(fbuf),0);</span><br><span class="line">if(strncmp(fbuf,&quot;error&quot;,5)==0) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;没有这个文件\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">write(fd, fbuf, n);</span><br><span class="line">printf(&quot;have write %d byte\n&quot;,n);</span><br><span class="line">if(n &lt; sizeof(fbuf))</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">case 4: //上传客户端文件到 服务器</span><br><span class="line">printf(&quot;请输入要上传的的文件:例如:put xxx \n&quot;);</span><br><span class="line">fgets(cmd, sizeof(cmd),stdin); // 从键盘读 </span><br><span class="line">printf(&quot;cmd=%s\n&quot;,cmd);</span><br><span class="line">send(sockfd, cmd, strlen(cmd)-1, 0 ); //  -1 去掉最后的 \n  </span><br><span class="line">p = strtok(cmd, &quot; &quot;);</span><br><span class="line">p = strtok(NULL, &quot; &quot;);</span><br><span class="line">printf(&quot;客户要上传的文件:%s\n&quot;, p);</span><br><span class="line">p[strlen(p)-1]=0;</span><br><span class="line">fd=open(p,O_RDONLY);</span><br><span class="line">if(fd&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;没有该文件。\n&quot;);</span><br><span class="line">send(sockfd,&quot;error&quot;,5,0);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">n = read(fd,buf,1024);</span><br><span class="line">send(sockfd,buf,n,0);</span><br><span class="line">printf(&quot;have send %d bytes\n&quot;,n);</span><br><span class="line">if(n&lt;1024)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">break;</span><br><span class="line">case 5: //退出</span><br><span class="line">send(sockfd, &quot;quit&quot;, 4, 0 ); </span><br><span class="line">printf(&quot;I am leave\n&quot;);</span><br><span class="line">exit(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int init_server()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 1. socket 创建了一个基于数据报 TCP 的 套接字</span><br><span class="line">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">struct sockaddr_in saddr;</span><br><span class="line"></span><br><span class="line">// 初始化 服务器的地址</span><br><span class="line">saddr.sin_family = AF_INET; // ipv4 协议</span><br><span class="line">saddr.sin_port = htons(3001);</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY; // 让内核自己选一个合适的IP来绑定</span><br><span class="line">// 2. bind</span><br><span class="line">// 设置sockfd可以重复使用port</span><br><span class="line">int on = 1;</span><br><span class="line">int ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;on, sizeof(on));</span><br><span class="line">printf(&quot;ret = %d\n&quot;, ret);</span><br><span class="line"></span><br><span class="line">if (bind(sockfd, (const struct sockaddr *)&amp;saddr, sizeof(saddr)))</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;bind&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen(sockfd, 5);</span><br><span class="line"></span><br><span class="line">return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in caddr;</span><br><span class="line">socklen_t addrlen = sizeof(caddr);</span><br><span class="line">int newfd;</span><br><span class="line">pid_t pid;</span><br><span class="line">char cmd[20];</span><br><span class="line"></span><br><span class="line">int sockfd = init_server();</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">// newfd  用来跟 客户 通信的套接字</span><br><span class="line">newfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;addrlen);</span><br><span class="line">printf(&quot;有一个客户端连接服务器:newfd=%d\n&quot;, newfd);</span><br><span class="line">pid = fork();</span><br><span class="line">if (pid == 0) // 子进程 跟 newfd客户端 通信</span><br><span class="line">&#123;</span><br><span class="line">int fd, n;</span><br><span class="line">char buf[1024];</span><br><span class="line">char fbuf[1024];</span><br><span class="line">char *p;</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">memset(cmd, 0, sizeof(cmd));</span><br><span class="line">recv(newfd, cmd, 20, 0); // 接收客户端的命令:ls   get         put   quit</span><br><span class="line">if (0 == strcmp(cmd, &quot;ls&quot;))</span><br><span class="line">&#123;</span><br><span class="line">system(&quot;ls &gt; 1.txt&quot;);</span><br><span class="line">fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br><span class="line">n = read(fd, buf, 1024);</span><br><span class="line">send(newfd, buf, n, 0); // 发送服务器的文件列表给 客户端</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line">else if (0 == strncmp(cmd, &quot;get&quot;, 3)) // get 1.txt</span><br><span class="line">&#123;</span><br><span class="line">p = strtok(cmd, &quot; &quot;);</span><br><span class="line">p = strtok(NULL, &quot; &quot;);</span><br><span class="line">printf(&quot;客户要下载的文件:%s\n&quot;, p);</span><br><span class="line">// 读 1.txt 这个文件</span><br><span class="line">fd = open(p, O_RDONLY);</span><br><span class="line">if (fd &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;没有这个文件\n&quot;);</span><br><span class="line">send(newfd, &quot;error&quot;, 5, 0); // 告诉客户端</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">n = read(fd, buf, 1024);</span><br><span class="line"></span><br><span class="line">send(newfd, buf, n, 0);</span><br><span class="line">printf(&quot;have send %d byte\n&quot;, n);</span><br><span class="line">if (n &lt; 1024)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line">else if (0 == strncmp(cmd, &quot;put&quot;, 3)) // put 1.txt</span><br><span class="line">&#123;</span><br><span class="line">p = strtok(cmd, &quot; &quot;);</span><br><span class="line">p = strtok(NULL, &quot; &quot;);</span><br><span class="line">printf(&quot;客户要上传的文件为：%s\n&quot;, p);</span><br><span class="line">p[strlen(p)] = 0;</span><br><span class="line">fd = open(p, O_WRONLY | O_CREAT, 0644); // 创建文件</span><br><span class="line">if (fd &lt; 0)</span><br><span class="line">perror(&quot;open&quot;);</span><br><span class="line">while (1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">n = recv(newfd, fbuf, sizeof(fbuf), 0);</span><br><span class="line">if (strncmp(fbuf, &quot;error&quot;, 5) == 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;没有这个文件\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">write(fd, fbuf, n);</span><br><span class="line">printf(&quot;have write %d bytes\n&quot;, n);</span><br><span class="line">if (n &lt; sizeof(fbuf))</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else if (0 == strncmp(cmd, &quot;quit&quot;, 4)) // quit</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d socket leave\n&quot;, newfd);</span><br><span class="line">close(newfd);</span><br><span class="line">exit(0); // 子进程退出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题</title>
    <link href="https://navyliky.github.io.git/2024/07/29/%E4%BB%8B%E7%BB%8D/CPP/LeetCode%E5%88%B7%E9%A2%98/"/>
    <id>https://navyliky.github.io.git/2024/07/29/%E4%BB%8B%E7%BB%8D/CPP/LeetCode%E5%88%B7%E9%A2%98/</id>
    <published>2024-07-29T13:40:00.000Z</published>
    <updated>2024-08-01T15:37:03.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>雪崩时，没有一片雪花觉得自己有责任<br>-—伏尔泰 （启蒙思想家）</p></blockquote><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><blockquote><p>示例：<br>输入：s &#x3D; “babad”<br>输出：“bab”<br>解释：“aba” 同样是符合题意的答案。</p></blockquote><p>思路：<br>动态规划<br>动规五部曲：</p><ol><li><p>确定dp数组（dp table）以及下标的含义<br>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p></li><li><p>确定递推公式<br>在确定递推公式时，就要分析如下几种情况。</p></li></ol><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><p>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串<br>情况二：下标i 与 j相差为1，例如aa，也是文子串<br>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。<br>以上三种情况分析完了，那么递归公式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i][j]初始化的时候，就初始为false。</p><p>在得到[i,j]区间是否是回文子串的时候，直接保存最长回文子串的左边界和右边界，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">    left = i;</span><br><span class="line">    right = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化<br>dp[i][j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。</li></ol><p>所以dp[i][j]初始化为false。</p><ol start="4"><li>确定遍历顺序<br>遍历顺序可有有点讲究了。</li></ol><p>首先从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的。</p><p>dp[i + 1][j - 1] 在 dp[i][j]的左下角<br>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p><p>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的。</p><p>有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1][j - 1]都是经过计算的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">            maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">            left = i;</span><br><span class="line">            right = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组<br>解答如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1：<br>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：<br>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。<br>思路：纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> length = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><blockquote><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol></blockquote><blockquote><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><p>思路：<br>用斐波那契数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = q + p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>   偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p></blockquote><blockquote><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>  偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p></blockquote><p>思路：动态规划<br>对于第 k (k&gt;2) 间房屋，有两个选项</p><ol><li>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</li><li>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</li></ol><p>取两者最大即可<br>用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><p>dp[i]&#x3D;max(dp[i−2]+nums[i],dp[i−1])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。<br>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p><p>思路：<br>动态规划<br>动规五部曲分别为：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>则状态转移方程<br>dp(m,n)&#x3D;grid(m,n) + min{dp(m,n-1),dp(m-1,n)}, 当m&gt;0,n&gt;0</p><p>m&#x3D;0或n&#x3D;0时，即二维dp表格的首行，首列<br>dp(0,0)&#x3D;grid(0,0);<br>dp(0,n)&#x3D;dp(0,n-1)+grid(0,n);n&gt;&#x3D;1时<br>dp(m,0)&#x3D;dp(m-1,0)+grid(m,0);m&gt;&#x3D;1时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="type">int</span> row=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//首行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;col<span class="number">-1</span>;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i+<span class="number">1</span>]=dp[<span class="number">0</span>][i]+grid[<span class="number">0</span>][i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//首列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;row<span class="number">-1</span>;j++)</span><br><span class="line">            dp[j+<span class="number">1</span>][<span class="number">0</span>]=dp[j][<span class="number">0</span>]+grid[j+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;row;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">1</span>;n&lt;col;n++)&#123;</span><br><span class="line">                dp[m][n]=<span class="built_in">min</span>(dp[m][n<span class="number">-1</span>],dp[m<span class="number">-1</span>][n])+grid[m][n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p>一个机器人位于一个 m x n 网格的左上角 。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？<br>示例 1：</p><blockquote><p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：<br>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p></blockquote><ol><li>向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li></ol><blockquote><p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p></blockquote><blockquote><p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6</p></blockquote><p>我们令 dp[i][j] 是到达 i, j 最多路径</p><p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p><p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例 1：</p><blockquote><p>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br>示例 2：<br>输入：obstacleGrid &#x3D; [[0,1],[0,0]]<br>输出：1<br>思路：<br>1）对dp数组的第一行和第一列初始化时，一旦遇到障碍物，后续的元素都为0，因为都走不到了。<br>2）在递推的过程中，遇到障碍物就continue，dp数组的值为初始值0；</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; (obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>); i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m &amp;&amp; (obstacleGrid[j][<span class="number">0</span>]==<span class="number">0</span>); j++)</span><br><span class="line">            dp[j][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CPP语言基础知识点</summary>
    
    
    
    <category term="CPP" scheme="https://navyliky.github.io.git/categories/CPP/"/>
    
    
    <category term="CPP" scheme="https://navyliky.github.io.git/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CPP语言基础(一)</title>
    <link href="https://navyliky.github.io.git/2024/07/23/%E4%BB%8B%E7%BB%8D/CPP/%E5%AD%A6%E4%B9%A0_1/"/>
    <id>https://navyliky.github.io.git/2024/07/23/%E4%BB%8B%E7%BB%8D/CPP/%E5%AD%A6%E4%B9%A0_1/</id>
    <published>2024-07-23T13:40:00.000Z</published>
    <updated>2024-07-23T09:08:09.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生命是一袭华美的袍，爬满了蚤子<br>——张爱玲</p></blockquote><h2 id="命名空间的由来"><a href="#命名空间的由来" class="headerlink" title="命名空间的由来"></a>命名空间的由来</h2><pre><code> 命名空间（namespace），是c++引入的一种机制，namespace目的是用来解决全局变量名与函数名或函数名与函数名之间名称相同的冲突的。 </code></pre><h2 id="c-解决重名"><a href="#c-解决重名" class="headerlink" title="c++解决重名"></a>c++解决重名</h2><pre><code>    c++解决重名问题设计了namespace命名空间语法，定义格式为namespace  xx &#123;&#125;，namespace是关键字，xx是自定义的空间名称，大括号是范围限定，也就是括号内是一个整体空间，可以有任何东西，如变量、函数等，括号内可以直接引用，而括号外的想相互访问必须指定空间名称+内部名称，namespace看起来就像是一种前缀。namespace本质上就是改变全局变量或函数的链接属性，即改变作用域。</code></pre><h2 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h2><p> 命名空间的定义需要用到namespace关键字，后面跟上一对**{}**，{}里面包含了命名空间的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> tanghuan</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h2><p>1.直接使用 std :: cin<br>2.间接使用 using namespace A<br>就可以直接访问</p><h2 id="iostream-h和iostream的区别"><a href="#iostream-h和iostream的区别" class="headerlink" title="iostream.h和iostream的区别"></a>iostream.h和iostream的区别</h2><p>iostream.h:全局命名空间，结构化编程思想，可直接使用 cout<br>iostream：专用的命名空间std，面向对象 std :: cout，才可以用</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用不是定义一个新的变量，而是给已存在的变量取了一个别名，在语法上编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p><p>简单的说，引用就是给一个已存在的变量取一个别名。</p><ol><li>定义是必须初始化</li><li>一旦定义了就不能再改变了</li></ol><h3 id="引用的使用场景"><a href="#引用的使用场景" class="headerlink" title="引用的使用场景"></a>引用的使用场景</h3><ol><li>引用做函数形参</li><li>引用做返回值：传值返回时（return n），不是将n直接返回，而是将n给一个临时变量，这个临时变量再将值返回<br>而int &amp;add(int a, int b);使用引用返回时，返回的就是n</li></ol><p>注意： 由于引用返回的特性。如果Count函数中的n没有static修饰，此时系统为n在栈上开辟内存空间，当Count函数调用结束后，n的空间会还给操作系统。因为函数返回值的类型是引用类型，返回的是n的别名，通过返回的别名可以访问到系统先前为n开辟的那一块内存空间，但这块内存空间已经还给系统了，所以这样的访问是不安全的。</p><p>64x：指针的大小为8个字节</p><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><ol><li>空值区别：<br>引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化。</li><li>合法性区别：<br>在使用引用之前不需要测试它的合法性，指针总被测试，防止它为空</li><li>可修改区别<br>引用不可以改变指向，对一个对象”至死不渝”；但是指针可以改变指向，而指向其它对象。虽然引用不可以改变指向，但是可以改变初始化对象的内容</li><li>应用型区别<br>两种情况使用指针：</li></ol><ul><li>考虑存在不指向任何对象的可能</li><li>需要在不同时刻指向不同时刻<br>如果总是指向一个对象，并且指向过后就不再改变就使用引用</li></ul><p>const int *p<br>int const <em>p&#x2F;&#x2F;p是一个指针，可修改，但是</em>p所指向的内容不能修改（可以通过 p 修改它指向的对象，但不能通过 *p 修改指向的对象的值）<br>int *const p&#x2F;&#x2F;P 是一个指向 int 类型的常量指针，即一旦初始化后，不能再改变 P 所指向的地址，但可以通过 *P 修改其所指向的值<br>int *const *p&#x2F;&#x2F;不能修改指针本身，也不能修改它指向的整型指针,但可以通过这个整型指针修改所指向的值。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>为了解决一些频繁调用小函数大量消耗栈空间的问题，能提高效率<br>编译的时候，将函数的内容本地化；只适合简单的小函数，不能递归</p><p>与带参宏的区别：两者都实现代码本地化，将代码直接替换<br>宏是在编译预处理时进行字符替换，不进行类型判定<br>内联函数，是在编译过程中展开的，具有更强的约束性，让编译器检查出更多的错误，对参数的类型和参数的个数进行判定</p><p>在上下文切换过程中，需要进行现场的保护和恢复<br>保护：保存当前运行环境的PC</p><p>栈：局部变量，函数参数 地址从高往低增长<br>堆：地址从低往高增长<br>全局静态变量：<br>字符常量区：<br>代码区：</p><p>new和delete;<br>malloc和free；</p><p>new是运算符，可以重载，根据类型自己算，<em><strong>会根据特点类型的构造函数的处理来进行初始化,会调用相对应的构造函数和析构函数</strong></em>，delete只能单纯释放一个，使用delete[]来释放连续多个元素的空间<br>malloc是C库函数，按照字节分配，<em><strong>分配的类型是不会进行初始化,不会调用相对应的构造函数和析构函数</strong></em>，必须使用free来释放</p><blockquote><p>new和malloc 1<br>首先，他们第一个区别就是new和delete是运算符，可以直接使用；而malloc和free是库函数，在使用前需要引入头文件。</p></blockquote><blockquote><p>因为new已经指定类型了，不需要进行类型强转，使用起来非常简单；而malloc函数的返回值是void*，在接收返回值时还需要进行类型强转，没有new来的方便。</p></blockquote><blockquote><p>new和malloc 2<br>第二个不同就是new除了可以申请动态内存外，还可以做内存初始化操作，而malloc是不支持初始化操作的。</p></blockquote><blockquote><p>new和malloc 3<br>第三个不同就是在内存申请失败时的处理方式。<br>malloc申请内存失败，是通过返回值是否是空指针来判断的；而new申请内存失败，是通过抛出bad_alloc类型的移除来判断的。</p></blockquote><blockquote><p>delete和free 1<br>在动态申请一个数组时，free释放内存直接把申请的数组的起始地址传进去即可；而delete在释放时需要加上[ ] ：delete []</p></blockquote><h2 id="C-中的结构体"><a href="#C-中的结构体" class="headerlink" title="C++中的结构体"></a>C++中的结构体</h2><p>在C语言中，使用结构体来定义自定义数据类型，它只是若干数据成员按照一定的顺序组织在一起形成的一种新的数据类型<br>C++的结构体是一种新的类型定义，包含属性和行为(包含数据和函数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; score:&quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student st = &#123;<span class="number">18</span>, <span class="string">&quot;Johnny&quot;</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    Student *pst = &amp;st;</span><br><span class="line">    pst-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">// 类的无参构造函数，默认的构造函数，类中无任何版本的构造函数，那么编译器会自动生成一个无参构造函数</span></span><br><span class="line">    <span class="comment">// 一旦实现了有参构造函数，那么编译器就不会自动生成无参构造函数</span></span><br><span class="line">    <span class="comment">// 构造函数的特点：</span></span><br><span class="line">    <span class="comment">// 1.构造函数的函数名和类名相同，不能有返回值类型</span></span><br><span class="line">    <span class="comment">// 2.构造函数的作用是在实例化对象分配内存空间（类的函数是不占内存的，所占的内存空间是所有数据成员的总和）</span></span><br><span class="line">    <span class="comment">// 3.构造函数可以重载</span></span><br><span class="line">    <span class="comment">// 4.对象实例化的时候，会自动调用构造函数，根据给定的参数，调用合适的构造函数</span></span><br><span class="line">    <span class="comment">// 5.如果没有实现构造函数，编译器会自动生成一个无参构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始值表达式初始化成员变量</span></span><br><span class="line">    <span class="comment">// 初始值表，分配对象空间时同时初始化成员变量</span></span><br><span class="line">    <span class="comment">// 函数体内的变量初始化，先分配内存空间，再初始化成员变量</span></span><br><span class="line">    <span class="built_in">Student</span>() : <span class="built_in">name</span>(<span class="string">&quot;张三&quot;</span>), <span class="built_in">age</span>(<span class="number">15</span>), <span class="built_in">score</span>(<span class="number">60</span>) <span class="comment">// 无参构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学生的构造函数Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// age = 0;</span></span><br><span class="line">        <span class="comment">// score = 0;</span></span><br><span class="line">        <span class="comment">// name = &quot;张三&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(string a, <span class="type">int</span> b, <span class="type">int</span> c) <span class="comment">// 重载的有参默认函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学生的构造函数Student(string a, int b, int c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        name = a;</span><br><span class="line">        age = b;</span><br><span class="line">        score = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数的特点：</span></span><br><span class="line">    <span class="comment">// 1.析构函数是类名前面加~</span></span><br><span class="line">    <span class="comment">// 2.析构函数没有返回值类型，没有参数，不能重载</span></span><br><span class="line">    <span class="comment">// 3.析构函数是在对象销毁的时候调用，释放对象的内存空间</span></span><br><span class="line">    <span class="comment">// 4.析构函数也是自动调用的</span></span><br><span class="line">    <span class="comment">// 5.如果类的数据成员都是栈上的，不需要手动实现析构函数；如果有指针类型，需要手动实现析构函数来释放内存空间</span></span><br><span class="line">    ~<span class="built_in">Student</span>() <span class="comment">// 析构函数,执行的顺序和构造函数相反</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学生&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;的析构函数~Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成绩：&quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1; <span class="comment">// 在实例化的时候，会自动调用构造函数</span></span><br><span class="line">    s1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 通过有参构造函数实例化</span></span><br><span class="line">    s2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Student) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    T t1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(T) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t1) &lt;&lt; endl; <span class="comment">// T类没有数据成员，所以大小为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CPP语言基础知识点</summary>
    
    
    
    <category term="CPP" scheme="https://navyliky.github.io.git/categories/CPP/"/>
    
    
    <category term="CPP" scheme="https://navyliky.github.io.git/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>摘抄</title>
    <link href="https://navyliky.github.io.git/2024/07/16/%E4%BB%8B%E7%BB%8D/%E6%91%98%E6%8A%84/%E6%91%98%E6%8A%84/"/>
    <id>https://navyliky.github.io.git/2024/07/16/%E4%BB%8B%E7%BB%8D/%E6%91%98%E6%8A%84/%E6%91%98%E6%8A%84/</id>
    <published>2024-07-16T13:40:00.000Z</published>
    <updated>2024-07-31T11:30:10.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>任何时候都不要指望婚姻拯救一个没有进步的你。婚姻的最大意义不是忠诚，而是成人之间伟大的友谊：“彼此不渗透、不求证、不表忠心，以专业收获尊重，以人格取得信任。伟大的友谊不是事无巨细地参与对方的生活，而是在惺惺相惜中保持和而不同。”</p></blockquote><blockquote><p>改变世界，从我做起，从你做起，从大家做起。如果对这个世界不满，对这个社会不满，请在抱怨的同时，从改变自己做起。<br>《疯狂动物城》</p></blockquote><blockquote><p>如果你遇到一堵墙，基于畏惧心理，纠结要不要爬的时候，就先把帽子丢过去；这样的话，接下来就根本不是犹豫要不要爬过去，而是怎么爬过去的问题。</p></blockquote><blockquote><p>如果孩子的出生，是为了继承自己的劳碌，恐慌，贫困，那么不生，也是一种善良。        –张爱玲</p></blockquote><blockquote><p>眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。<br>摘自《桃花扇·续四十出·余韵》</p></blockquote><blockquote><p>「教育的目的是教会人们如何思考，而不是告诉他们应该思考什么。」ーー约翰·杜威<br>“The purpose of education is to teach people how to think, not what to think.” - John Dewey</p></blockquote>]]></content>
    
    
    <summary type="html">摘抄</summary>
    
    
    
    <category term="摘抄" scheme="https://navyliky.github.io.git/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="摘抄" scheme="https://navyliky.github.io.git/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序设计-现代方法 代码（一）</title>
    <link href="https://navyliky.github.io.git/2024/07/08/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%AC%94%E8%AE%B0%20%E4%BB%A3%E7%A0%811/"/>
    <id>https://navyliky.github.io.git/2024/07/08/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%AC%94%E8%AE%B0%20%E4%BB%A3%E7%A0%811/</id>
    <published>2024-07-08T13:40:00.000Z</published>
    <updated>2024-07-30T15:39:31.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>围在城里的人想逃出来，城外的人想冲进去；<br>对婚姻也罢，职业也罢，人生的愿望大都如此！<br>——《围城》钱钟书</p></blockquote><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h3><ol><li>编写一个计算球体体积的程序，其中球体的半径为10 m，参考公式 v&#x3D;4&#x2F;3πr^3注意，分数4&#x2F;3应当写为4.0f&#x2F;3.0f。（如果分数写成4&#x2F;3会产生什么结果？）提示：C语言没有指数表达式。所以需要对 r 自乘两次来计算r^3<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">double</span> r = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> v = (<span class="number">4.0</span> / <span class="number">3.0</span>) * PI * r * r *r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;体积为%lf\n&quot;</span>,v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改上题中的程序，使我们自行录入半径。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">double</span> r ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入球的半径：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;r);</span><br><span class="line">    <span class="type">double</span> v = (<span class="number">4.0</span> / <span class="number">3.0</span>) * PI * r * r *r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;体积为%lf\n&quot;</span>,v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编写一个程序，要求用户输入一个美金数量，然后评级增加5%后的相应金额。格式概要：</li></ol><p>Enter an amount: 100.00<br>With tax added: $105.00</p>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序设计-现代方法 读书笔记（一）</title>
    <link href="https://navyliky.github.io.git/2024/07/08/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%AC%94%E8%AE%B01/"/>
    <id>https://navyliky.github.io.git/2024/07/08/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%AC%94%E8%AE%B01/</id>
    <published>2024-07-08T13:40:00.000Z</published>
    <updated>2024-07-08T09:04:51.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习不是填满水桶，而是点燃火焰！<br>Education is not the filling of a pail but the lighting of a fire.<br>——叶芝 （爱尔兰诗人）</p></blockquote><h2 id="C-语言的历史"><a href="#C-语言的历史" class="headerlink" title="C 语言的历史"></a>C 语言的历史</h2><h3 id="基于C语言"><a href="#基于C语言" class="headerlink" title="基于C语言"></a>基于C语言</h3><ul><li>C++：包括了所有C的特性，但增加了类和其他面向对象编程的特性。</li><li>Java：基于C++的，所以也继承了C的的许多特性。</li><li>C#：是由 C++ 和 Java 发展起来的一种较新的语言。</li><li>Perl：最初是一种复杂的脚本语言，在发展过程中涉及C的许多特性。</li></ul><h3 id="C语言的优缺点"><a href="#C语言的优缺点" class="headerlink" title="C语言的优缺点"></a>C语言的优缺点</h3><ul><li>C语言是一种底层语言。C语言提供了许多机器概念，也提供了与计算机内置指令协调的操作。</li><li>C语言是一种小型语言。C语言很大程度上依赖于标准库。</li><li>C语言是一种包容性的语言。</li></ul><h4 id="C-语言功能"><a href="#C-语言功能" class="headerlink" title="C 语言功能"></a>C 语言功能</h4><ul><li>C 语言是一种汇编语言，它能够将 C 语言程序编译成 C 程序，供计算机使用，是一种非常实用的编程语言。</li><li>可移植。</li><li>功能。</li><li>灵活。</li><li>标准库。</li><li>与 UNIX 系统集成。</li></ul><h4 id="C语言的缺点"><a href="#C语言的缺点" class="headerlink" title="C语言的缺点"></a>C语言的缺点</h4><ol><li>C 程序更容易出错。</li><li>C 程序可能会难以被人阅读和理解。</li><li>C 程序可能会难以修改。</li></ol><h2 id="C语言基本概念"><a href="#C语言基本概念" class="headerlink" title="C语言基本概念"></a>C语言基本概念</h2><p>主要内容有预处理指令、函数、变量和语句。程序需要编译和链接。</p><ul><li>Objective S 是用于存储数据的程序，它的过程可改变数据。</li><li>常量是执行程序的过程不会改变数据。</li></ul><h3 id="编写一个简单的C程序"><a href="#编写一个简单的C程序" class="headerlink" title="编写一个简单的C程序"></a>编写一个简单的C程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含了C语言输入输出标准库的相关信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显示期望信息，printf 函数来自标准输入输出库</span></span><br><span class="line">    <span class="comment">// 产生格式化输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;To C, or not to C: that is the question.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>将 C 语言程序转化为机器可以执行以下三个步骤：</p><ul><li>预处理：首先程序回被交给预处理器（预处理器）。预处理器执行以#开头的命令（通常称为指令）。预处理器有点类似于编辑器， Func给源代码添加内容，也可以对程序进行修改（简单来说就是将头文件中的代码粘贴进源代码）。</li><li>编译：修改后的程序被找到了编译器（compiler）。这个阶段得到的是一个编译语言写成的文件，本质上还是一个文本文件，文件扩展名.s。</li><li>汇编：汇编器将汇编文件翻译成机器语言指令，并且管理指令打包成一个叫做“可重定位目标程序”的格式，这时得到的文件扩展名为.o。该文件是一个二进制文件。</li><li>链接：链接器（linker）把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才可执行的程序。</li></ul><h4 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h4><p>集成开发环境（IDE）是一个软件包（或者就是一个程序，比如Visual Studio），可以在其中编辑、编译、链接、执行甚至调试程序。</p><h3 id="简单程序的一般形式"><a href="#简单程序的一般形式" class="headerlink" title="简单程序的一般形式"></a>简单程序的一般形式</h3><p>简单的C程序一般有如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指令</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言程序依赖的三个关键的语言特性：</p><ul><li>指令：在编译前修改程序的编辑命令。</li><li>函数：被命名的可执行代码块，如main函数。</li><li>语句：程序运行时执行的命令。</li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>预处理器首先进行编辑。我们把预处理器执行的命令指令。</p><p>所有的指令都是以字符#开始的。这个字符可以把 C 程序中的指令和其他代码区分开来。指令只占一行，每条指令的结尾没有分号或者其他标记。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数式编程 类似于 变成中的过程。 它们用来构建程序的模块。C 语言就是函数式编程。</p><p>函数分为两大类：</p><p>程序员自己编写的函数。<br>作为 C 语言实现的一部分提供的函数，也就是库函数。<br>虽然一个 C 程序可以包含多个函数，但是main函数是必须有的。main函数非常特殊：在执行程序时系统会自动调用main函数。</p><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>语句就是程序运行时执行的代码。比方说上面这个程序使用返回值和调用语句。调用语句就是给一个要执行的函数执行任务。</p><p>C 语言规定每条语句均以分号结尾，因为语句可以连续占用一行，因此不需要分号结尾。</p><h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><p>目前为止，我们只使用了printf函数显示出的字符串量用一对引号包围的一系列字符。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>每一个程序都应该包含识别信息，C语言把创新信息放在注释中。标记&#x2F;<em>注释的开始，而标记</em>&#x2F;注释的结束。注释不能嵌套。但可以鼓励多行。</p><p>建议男孩建议方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment"> * Name: pun.c</span></span><br><span class="line"><span class="comment"> * Purpose: Prints a bad pun    // 块注释</span></span><br><span class="line"><span class="comment"> * Author: K. N. King</span></span><br><span class="line"><span class="comment"> *****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Beginning of main program */</span> <span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>指针函数和函数指针</title>
    <link href="https://navyliky.github.io.git/2024/07/04/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B91/"/>
    <id>https://navyliky.github.io.git/2024/07/04/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B91/</id>
    <published>2024-07-04T13:40:00.000Z</published>
    <updated>2024-07-04T13:52:50.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁而无比强烈的激情支配着我的一生。<br>——《我为什么而活着》罗素 （哲学家 数学家 思想家）</p></blockquote><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>顾名思义，它的本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret *<span class="title function_">func</span><span class="params">(args, ...)</span>;</span><br></pre></td></tr></table></figure><p>其中，func是一个函数，args是形参列表，ret *作为一个整体，是 func函数的返回值，是一个指针的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">func_sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error:n must be &gt; 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input one number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="type">int</span> *p = func_sum(num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum:%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码使用普通的局部变量来实现，也是可以的，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_sum2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error:n must be &gt; 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input one number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="type">int</span> ret = func_sum2(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum2:%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的<strong>局部变量</strong>是存放于<em><strong>栈区</strong></em>的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。上面的示例中，在返回该指针后，立即访问，的确是得到了正确的结果，但这只是十分巧合的情况，如果我们等待一会儿再去访问该地址，很有可能该地址已经被其他的变量所占用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。<br><em><strong>因此，在使用指针函数的时候，一定要避免出现返回局部变量指针的情况。 ***<br>那么为什么用了static就可以避免这个问题呢？<br>原因是一旦使用了static去修饰变量，那么该变量就变成了静态变量。而</strong>静态变量</em><em>是存放在</em><strong>数据段</strong>*的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。<br>因此，还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。<br>我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。<br>其声明形式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret (*p)(args, ...);</span><br></pre></td></tr></table></figure><p>其中，ret为返回值，<strong>p作为一个整体，代表的是指向该函数的指针，args为形参列表。其中p被称为函数指针变量。</strong><br>关于函数指针的初始化<br>与数组类似，在数组中，数组名即代表着该数组的首地址，函数也是一样，函数名即是该数组的入口地址，因此，函数名就是该函数的函数指针。<br>因此，我们可以采用如下的初始化方式：<br>函数指针变量 &#x3D;  函数名; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">//函数指针的定义</span></span><br><span class="line">    <span class="comment">//int (*p)();       //函数指针的另一种定义方式，不过不建议使用</span></span><br><span class="line">    <span class="comment">//int (*p)(int a, int b);   //也可以使用这种方式定义函数指针</span></span><br><span class="line">    </span><br><span class="line">    p = max;    <span class="comment">//函数指针初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = p(<span class="number">10</span>, <span class="number">15</span>);    <span class="comment">//函数指针的调用</span></span><br><span class="line">    <span class="comment">//int ret = (*max)(10,15);</span></span><br><span class="line">    <span class="comment">//int ret = (*p)(10,15);</span></span><br><span class="line">    <span class="comment">//以上两种写法与第一种写法是等价的，不过建议使用第一种方式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d \n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要使用函数指针？"><a href="#为什么要使用函数指针？" class="headerlink" title="为什么要使用函数指针？"></a>为什么要使用函数指针？</h3><p>那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。<br>举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针的一个非常典型的应用就是回调函数。<br>什么是回调函数？<br>回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。<br>回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。<br>同样我们来看一个回调函数的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：实现累加求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;n must be &gt; 0\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> (*p)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> p(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the sum from 0 to %d is %d\n&quot;</span>, n, callback(n, func_sum));       <span class="comment">//此处直接调用回调函数，而不是直接调用func_sum函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>IPC</title>
    <link href="https://navyliky.github.io.git/2024/07/02/%E4%BB%8B%E7%BB%8D/IPC/"/>
    <id>https://navyliky.github.io.git/2024/07/02/%E4%BB%8B%E7%BB%8D/IPC/</id>
    <published>2024-07-02T12:13:00.000Z</published>
    <updated>2024-07-02T11:42:16.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我每天都自问：＂如果今天是我生命的最后一天，我还会做今天要做的事情吗？＂<br>如果连续很多天得到【否定】的回答，那我就需要作出一些改变了。<br>——乔布斯</p></blockquote><p>Inter process communication —&gt; 进程间通信<br>实质：信息的交换</p><h2 id="为什么需要进程间通信"><a href="#为什么需要进程间通信" class="headerlink" title="为什么需要进程间通信"></a>为什么需要进程间通信</h2><p>1).数据传输</p><p>一个进程需要将它的数据发送给另一个进程。</p><p>2).资源共享</p><p>多个进程之间共享同样的资源。</p><p>3).通知事件</p><p>一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。</p><p>4).进程控制</p><p>有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</p><h2 id="什么是进程间通信"><a href="#什么是进程间通信" class="headerlink" title="什么是进程间通信"></a>什么是进程间通信</h2><p>进程隔离：<br>       进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。<br>虚拟地址空间：<br>        就32位系统而言，当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从 0x00000000~0xFFFFFFFF ，最大值 0xFFFFFFFF 表示的即为 4GB 大小的容量。4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。<br>        针对 Linux 操作系统，将最高的1G字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF ）供内核使用，称为内核空间，而较低的 3G 字节（从虚拟地址 0x00000000 到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程都可以通过系统调用进入到内核。其中在 Linux 系统中，进程的用户空间是独立的，而内核空间是共有的，进程切换时，用户空间切换，内核空间不变。</p><h2 id="IPC通信原理"><a href="#IPC通信原理" class="headerlink" title="IPC通信原理"></a>IPC通信原理</h2><p> 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信机制。通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，内核空间调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的用户空间内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>  IPC的方式通常有linux下的 管道（Streams)（包括无名管道和命名管道）、消息队列、信号量、信号、共享存储、Socket等。其中 Socket和Streams支持不同主机上的两个进程IPC，以及android下的Binder。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。<br>pipe(无名管道)特点：<br>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。<br>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。<br>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，调用pipe函数 在内核中开辟一块缓冲区用于通信，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>],n;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">pipe(fd);<span class="comment">//创建一个无名管道</span></span><br><span class="line"></span><br><span class="line">pid=fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);<span class="comment">//关闭读描述符</span></span><br><span class="line">write(fd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">n=read(fd[<span class="number">0</span>],buf,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i have receive %d words:buf is %s\n&quot;</span>,n,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>FIFO，也称为命名管道，它是一种文件类型<br>特点:<br>FIFO可以在无关的进程之间交换数据，与无名管道不同。<br>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I&#x2F;O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：</p><blockquote><p>若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p></blockquote><blockquote><p>若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd_r,fd_w;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">fd_w=open(<span class="string">&quot;/tmp/fifo1&quot;</span>,O_RDWR);</span><br><span class="line">fd_w=open(<span class="string">&quot;/tmp/fifo2&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line">pid=fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(fd_r,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">write(fd_w,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是一种事件通知机制，当接收到该信号的进程会执行相应的操作。<br>特点:</p><ul><li><p>由硬件产生，如从键盘输入Ctrl+C可以终止当前进程</p></li><li><p>由其他进程发送，例如，在shell进程下，使用命令kill  -信号值 PID</p></li><li><p>异常，当进程异常时发送信号</p></li></ul><p>信号是由操作系统处理的，所以信号的处理在内核态。如果不是紧急信号的话，它不一定被立即处理，操作系统不会为了处理一个信号而把当前正在运行的进程挂起，因为挂起（进程切换）当前进程消耗很大。所以操作系统一般会将信号先放入信号表中，一般选择在内核态切换回用户态的时候处理信号（不用自己单独进行进程切换以免浪费时间）</p>]]></content>
    
    
    <summary type="html">进程间通信</summary>
    
    
    
    <category term="IPC" scheme="https://navyliky.github.io.git/categories/IPC/"/>
    
    
    <category term="IPC" scheme="https://navyliky.github.io.git/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>静态查找</title>
    <link href="https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/"/>
    <id>https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/</id>
    <published>2024-06-29T13:40:00.000Z</published>
    <updated>2024-06-29T14:51:29.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不要去欺骗别人——因为你能骗到的，都是相信你的人</p></blockquote><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p> 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；而是查找失败。</p><p> 查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种：</p><p>1.查询某个特定的数据元素是否在查找表中；</p><p>2.检索满足条件的某个特定的数据元素的各种属性；</p><p>3.在查找表中插入一个数据元素；</p><p>4.从查找表中删除某个数据元素；</p><p>静态查找表：若一个查找表的操作只涉及上述操作的1和2，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态的插入或删除的查找表称为动态查找表。适合静态查找表的的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和B树都是二叉排序树的改进。</p><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中 “学号” 这一数据项的值唯一地标识一名学生。</p><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p> 顺序查找又称为线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过 next 指针来依次扫描每个元素。顺序查找通常分为对一般的<strong>无序线性表</strong>的顺序查找和对按<strong>关键字有序</strong>的线性表的顺序查找。</p><h4 id="线性表的顺序查找"><a href="#线性表的顺序查找" class="headerlink" title="线性表的顺序查找"></a>线性表的顺序查找</h4><p> 这里是无序线性表的顺序查找，基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]==key)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">a[<span class="number">0</span>]=key;</span><br><span class="line">i=n;</span><br><span class="line"><span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环的时候，我们都要判断i是否小于等于n，也就是无哨兵，这里就浪费了效率，所以我们就设置了一个哨兵，通常都是数组的第一个元素，将key赋值给它，然后i就从最大的开始每次都-1，这里就不需要再判断了，因为就算没有找到，循环遇到数组的第一个元素也会跳出，这里就会提高一些效率。</p><p>查找最好的情况就是第一次就找到了，时间复杂度为O(1),最坏的情况是直到最后一个才找到，时间复杂度为O(n),取平均情况就为O((n+1)&#x2F;2),所以这个算法的最终时间复杂度就为O(n)。</p><h4 id="线性表的折半查找"><a href="#线性表的折半查找" class="headerlink" title="线性表的折半查找"></a>线性表的折半查找</h4><p>这里是有序的线性表查找，基本思想是首先将给定值 key 与表中<em><strong>中间位置</strong></em>的元素进行比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;<span class="comment">/* 折半 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以把它看作是具有n个节点的完全二叉树，深度就为log2(n)+1,最好的情况就是第一次就找到了，最坏的情况跟这颗二叉树的深度有关，所以这个算法的时间复杂度就为logn,相比较于顺序查找，效率还是快很多。</p><h4 id="线性表的插值查找"><a href="#线性表的插值查找" class="headerlink" title="线性表的插值查找"></a>线性表的插值查找</h4><p>我们在查字典时，如果需要查找的是cook，就会从前面开始翻找，如果查找的是zoo，就会从后面开始翻找，所以对折半查找进行优化，我们不必每次都从中间开始找，而是按照比例（c字母在26个字母是前三个，假如这个字典，是2600页，那么你要查找的区间大概率为前三百页），当然这个算法只用于比较均匀的数据（说了是大概率），如果不均匀，那么这个算法就毫无优势。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Interpolation_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性表的斐波那契查找"><a href="#线性表的斐波那契查找" class="headerlink" title="线性表的斐波那契查找"></a>线性表的斐波那契查找</h4><p>基本思想 这个想法是首先找到大于或等于给定数组长度的最小斐波那契数。令找到的斐波那契数为 fib（第 m 个斐波那契数）。我们使用第 (m-2) 个斐波那契数作为索引（如果它是有效索引）。设第(m-2)个斐波那契数为i，我们将arr[i]与x进行比较，如果x相同，则返回i。否则，如果 x 更大，则对 i 之后的子数组进行递归，否则对 i 之前的子数组进行递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">a[i]=a[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">k=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">k=k<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>组播广播</title>
    <link href="https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/"/>
    <id>https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/</id>
    <published>2024-03-22T13:40:00.000Z</published>
    <updated>2024-06-29T14:51:39.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果说调试（debug）是去除 bug 的过程，那么编程就是制造 bug 的过程。<br>——Edsger Dijkstra （图灵奖得主）</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 三种IP地址：单播地址、广播地址和组播地址。广播和多播仅应用于UDP（因为TCP是端对端的连接，无法实现一对多）。</p><p>单播，一对一，目的地址是单个主机；</p><p>广播，一对全部，目的地址是局域网中的全部主机；</p><p>多播，一对部分，目的地址是局域网中的部分主机；广播也是多播的一种特殊形式，即目的地址为全部主机。</p><p>TCP是一个面向连接的协议，TCP一定是点对点的，一点是两个主机来建立连接的，TCP肯定是单播。只有UDP才会使用广播和组播。</p><p>有时一个主机要向网上的所有其它主机发送帧，这就是广播，广播分为二层广播（目的MAC全F）和三层广播（IP地址的主机位全1），二层广播是不能跨路由器的，三层广播是可以跨路由器路由的。</p><p>多播属于单播和广播之间，帧仅传送给属于多播组的多个主机。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播的例子随处可见，比如说把屏幕共享给很多人，其实也是广播，首先把屏幕截图，然后广播给所有的客户端，比如说屏幕共享软件，一般都有一个广播地址，只要在同一个网段的客户端都能收到广播，如果设置广播地址为255.255.255.255，那么不管哪个网段都能收到广播。屏幕共享软件会把当前屏幕截图并分为很多小块，然后压缩，广播给所有客户端，客户端再进行解压。</p><p> 广播地址：<br>子网广播地址：x.x.x.255 (主机号全部为1)的地址，我们称为广播地址</p><p>192.168.31.105<br>255.255.255.0<br>网段号 &#x3D; IP &amp; netmask &#x3D; 192.168.31<br>广播地址： 192.168.31.255<br>255.255.255.255 全网广播地址<br>很多路由器设置：禁止全网广播<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》很有可能造成网络风暴<br>广播的工作过程：<br>广播发送者：<br>socket<br>使能广播功能 setsockopt<br>sendto<br>广播接收者：<br>socket<br>使能广播功能 setsockopt<br>bind x.x.x.255 + 端口号<br>recvfrom</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">broadcast_onoff</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (<span class="type">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt SO_BOARDCAST error:&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h2><p>(1) 多播也只有对传输协议为 UDP才支持<br>(2) 多播地址 IP地址 D类地址<br>224.0.0.0 —- 239.255.255.255<br>(3) 广播式发送，占用大量的带宽，造成广播风暴<br>多播是一种折中方式，只有加入 某个多播组才能收到信息<br>（4） 多播编程思路：<br>多播发送者：<br>socket<br>sendto : D类地址 + 端口号<br>……<br>recvfrom<br>多播接收者：<br>socket<br>加入多播组<br>bind: D类地址+port<br>recvfrom<br>如何加入多播组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line">inet_aton(<span class="string">&quot;224.0.0.1&quot;</span>, &amp;mreq.imr_multiaddr); <span class="comment">//D类地址</span></span><br><span class="line">mreq.imr_interface.s_addr = INADDR_ANY; <span class="comment">//由内核找个合适网卡IP</span></span><br><span class="line"><span class="comment">//加入多播组：</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="type">void</span> *)&amp;mreq, sizeo</span><br><span class="line">f(mreq));</span><br></pre></td></tr></table></figure><p>struct ip_mreq {<br>struct in_addr imr_multiaddr; &#x2F;* IP multicast address of<br>group <em>&#x2F;<br>struct in_addr imr_interface; &#x2F;</em> local IP address of<br>interface *&#x2F;<br>};<br>imr_multiaddr： 多播组地址，D类地址，逻辑上的组号，用来<br>区分不同的多播组，<br>但是这个逻辑上的地址，在真正收发数据的时<br>候，一定要依赖真正的网卡<br>这种接口<br>imr_interface： 接口地址</p>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(二)</title>
    <link href="https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/"/>
    <id>https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/</id>
    <published>2024-01-28T13:40:00.000Z</published>
    <updated>2024-07-02T05:13:17.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>许多人所谓的成熟，不过是被习俗磨去了棱角，变得世故而实际了；那不是成熟，而是精神的早衰和个性的夭亡！<br>真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。<br>——《在世纪的转折点上》尼采 （哲学家 思想家）</p></blockquote><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>1） for 语句语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号的内容是用来描述控制循环的变量的变化过程。</p><ol><li>循环变量的初始化 i&#x3D;1；</li><li>循环结束的条件(逻辑表达式，为真继续循环，为假结束循环) i&lt;100;</li><li>每次循环对循环变量的操作 i++</li><li>要循环的语句<br>他是按照这个顺序执行： {1,2},{4,3,2},{4,3,2},{4,3,2},,{4,3,2},{4,3,2},<br>正常情况下(没有break)： 正常结束<br>continue; 在循环中碰到这个continue,跳过下面的语句，重新开始下一次循环<br>循环嵌套——- 有多层循环</li></ol>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(一)</title>
    <link href="https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/"/>
    <id>https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/</id>
    <published>2024-01-27T13:40:00.000Z</published>
    <updated>2024-07-02T05:13:12.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最多人走的路肯定最安全<br>但别指望会在这样的路上碰到很多猎物<br>——纪德 （作家 诺贝尔奖得主)</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者将把C语言的知识要点，学习心得以博客形式发表，希望通过这种形式督促自身的学习，也能在这里与大家共同进步，早日成为大牛！</p><p>本系列（初始C语言）只是简单介绍每个知识点、C语言的基础知识，意在使读者（还有自己）大概了解C语言。</p><h2 id="初始C语言"><a href="#初始C语言" class="headerlink" title="初始C语言"></a>初始C语言</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//字符数据类型//就是不是数字的字符</span></span><br><span class="line"><span class="type">short</span><span class="comment">//短整型//就是数字小（绝对值）的整数，很少用</span></span><br><span class="line"><span class="type">int</span> <span class="comment">//整型//就是整数</span></span><br><span class="line"><span class="type">long</span><span class="comment">//长整型//就是数字（绝对值）大的整数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span><span class="comment">//更长的整型//很少用</span></span><br><span class="line"><span class="type">float</span><span class="comment">//单精度浮点数//就是小数</span></span><br><span class="line"><span class="type">double</span><span class="comment">//双精度浮点数//小数位数多的小数</span></span><br></pre></td></tr></table></figure><p>分这么多数据类型的原因：不同数据类型在内存中所占大小是不一样的，如果用大小的盒子装蛋糕，蛋糕有大有小，难免造成空间的浪费，所以人们规定了不同的数据类型，以便空间被物尽其用。</p><h3 id="字符类型—char"><a href="#字符类型—char" class="headerlink" title="字符类型—char"></a>字符类型—char</h3><p>字符类型是一种数据类型，包含256个不同的字符数据,字符数据类型的范围是 -128 - 127(-2^7—2^7-1)<br>在内存中占一个字节（Byte）,在C语言中要使用单引号包含起来，’a’ ‘1’ ‘+’,它也是一个关键字，字符数据也可以用数字表示，字符数据有两种的身份，字符身份和数字身份，字符身份和数字身份的对应关系由ASCII码表定义：<br>man ascii ———- 查看ascii表<br>‘a’ ————– 97<br>‘1’ ————– 49<br>‘+’ ————— 43<br><strong>BIN</strong>: 2进制 ， 只有0和1，两种数组的数据，计算机只认识二进制： 逢2进1。<br>101010 —&gt; 2^5+2^3+2^1 &#x3D; 32+8+2 &#x3D; 42<br><strong>OCT</strong> : 8进制 ， 是以0开头的，逢8进1。<br>027 —-&gt; 2<em>8+7 &#x3D; 23<br>0123 —-&gt; 1</em>8^2+2<em>8^1 + 3</em>8^0 &#x3D; 64 + 16 + 3 &#x3D; 83<br>使用占位符%o将数字的8进制形式打印出来<br><strong>DEC</strong>：10进制<br><strong>HEX</strong>： 16进制 : 0x 开头表示 16进制 ,逢16进1<br>0x27 —-&gt; 2<em>16^1 + 7</em>16^0 &#x3D; 32+7 &#x3D; 39<br>0x123 —&gt;1<em>16^2+2</em>16^1 + 3 *16^0 &#x3D; 256 + 32 + 3 &#x3D;291<br>使用占位符%x %X打印数字的16进制形式<br>十进制 转换为 二进制 ： 134<br>方法1：<br>把十进制数字拆分成多个2的整数次方之和，然后把每个拆分结果单独转换成二进制，随后把所有的结果合并<br>179 &#x3D; 128 + 32 + 16 + 2 + 1<br>&#x3D; 2^7 + 2^5 + 2^4 + 2^1 + 2^0<br>&#x3D; 10110011<br>方法2：把十进制数组不停地除以2直到结果为0，然后把所有的余数倒着写就是对应的二进制数<br>134 0<br>67 1<br>33 1<br>16 0<br>8 0<br>4 0<br>2 0<br>1 1<br>0<br>10000110<br>使用以上方法得到的是对应数字二进制的 <em><strong>原码</strong></em><br>计算机中实际上保存的是二进制的 <em><strong>补码</strong></em><br>所有非负数的补码就是原码 134 –&gt; （原码，补码 ）<br>10000110<br><strong>负数的补码等于原码取反加1</strong> ： -6<br>-6 ： 1000000000000000000000000000110 —</p><blockquote><p>11111111111111111111111010<br>计算机保存有符号的数据时，最高位是符号位，0表示正数，1表示负数<br>使用printf打印字符变量时，使用%d打印数字，使用%c打印字符<br>0-127范围内字符身份和数字身份的对应关系是固定的，所有的计算机都一样<br>‘\n’ —————– 换行符<br>‘\r’ —————– 移动光标到行首<br>‘\t’—————— 制表符<br>‘\b’—————— 退格键<br>‘ “ \在打印时需要转义 —————- &quot; &#39; \<br>ascii表中，数字，大写字母，小写字母是连续的<br>‘b’ - ‘a’ &#x3D; ‘B’ - ‘A’<br>‘g’ - ‘d’ &#x3D; ‘3’ - ‘0</p></blockquote><h3 id="字符类型—无符号字符类型-没有负数-unsigned-char"><a href="#字符类型—无符号字符类型-没有负数-unsigned-char" class="headerlink" title="字符类型—无符号字符类型 (没有负数) unsigned char"></a>字符类型—无符号字符类型 (没有负数) unsigned char</h3><p>范围0-255，同样包含256个不同的字符<br>其他性质和char类型相同</p><h3 id="字符类型—短整型-short-int"><a href="#字符类型—短整型-short-int" class="headerlink" title="字符类型—短整型 short int"></a>字符类型—短整型 short int</h3><p>16位： 2^16次方,短整型包含65536个不同的整数，范围从-32768 - 32767<br>类型名short,占用内存2个字节<br>对应的占位符是%hd —-&gt; half d</p><h3 id="字符类型—整型-int"><a href="#字符类型—整型-int" class="headerlink" title="字符类型—整型 int"></a>字符类型—整型 int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名int,占用内存4个字节<br>对应的占位符%d</p><h3 id="字符类型—无符号整型-unsigned-int"><a href="#字符类型—无符号整型-unsigned-int" class="headerlink" title="字符类型—无符号整型 unsigned int"></a>字符类型—无符号整型 unsigned int</h3><p>范围 0 - 2^32-1<br>占位符%u<br>注:类型名中int可以省略<br>其他性质和int相同</p><h3 id="字符类型—长整型-long-long-int"><a href="#字符类型—长整型-long-long-int" class="headerlink" title="字符类型—长整型 long&#x2F;long int"></a>字符类型—长整型 long&#x2F;long int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名long,占用内存4个字节<br>对应的占位符%ld</p><h3 id="字符类型—无符号长整型-unsigned-long-unsigned-long-int"><a href="#字符类型—无符号长整型-unsigned-long-unsigned-long-int" class="headerlink" title="字符类型—无符号长整型 unsigned long&#x2F;unsigned long int"></a>字符类型—无符号长整型 unsigned long&#x2F;unsigned long int</h3><p>范围 0 - 2^32-1<br>占位符%lu<br>h—-&gt; half<br>u—-&gt; usigned<br>l —–&gt;long<br>d—–&gt; int</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>计算机使用浮点类型来记录带小数点的数字，浮点类型分为两<br>种：<em><strong>单精度浮点型和双精度浮点型</strong></em><br>单精度浮点型对应的类型名是float,占用4个字节<br>占位符：%f %g (%g不保留小数点后的0)<br>双精度浮点型对应的类型名是double，占用8个字节<br>占位符：%lf %lg<br>计算机中的整数默认是int型，可以在数字后加u表示该数字是无<br>符号整型，比如:8u<br>计算机中的小数默认是double型，可以在数字后加f表示该数字<br>是单精度浮点型，比如：4.1f<br>注：可以使用sizeof获取类型，变量，数字的大小</p>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>个人介绍</title>
    <link href="https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    <id>https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-01-24T12:13:00.000Z</published>
    <updated>2024-07-16T12:00:11.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人的一切痛苦都是源于对自己无能的愤怒<br>——王小波 （作家）</p></blockquote><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我叫小王，英文名navy（在百度上搜索关于颜色的英文当中随便选的一个单词，也作为我最喜欢的单词之一）。对于自己的介绍，实在无病呻吟啰嗦很多，作为芸芸众生的其中之一，没有太值得炫耀的东西，但总的来说，也不算太糟糕。</p><h2 id="喜欢的运动"><a href="#喜欢的运动" class="headerlink" title="喜欢的运动"></a>喜欢的运动</h2><p>小学一直热爱的乒乓球，当时我们学校一共就几个乒乓球桌，为了占位置，可以中饭都不去吃。从初中开始，喜欢上了篮球，直到高一，还参加我们篮球校队的培训，但本人身体天分实在有限。大三又开始天天打台球，看斯诺克</p><h2 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h2><p>本博客基于Hexo，所以首先要了解一下我们搭建博客所要用到的框架。Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到github或者coding等代码管理托管平台，然后别人就可以浏览你的博客网页啦。</p><p>关于做这个博客的目的，我也并不是很清楚，当初就看到了几个大佬的博客，觉得很酷，就在网上看各种教程，最终东拼西凑，成了这个样子，做完之后好像也没写啥东西（我好像就这样，三分钟热情），但时隔几个月，发现这个也能成自己面试时的一个自我介绍的加分项吧，所以写写东西，也算对自己学的东西的总结。</p><h2 id="博客流程"><a href="#博客流程" class="headerlink" title="博客流程"></a>博客流程</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>为了把本地的网页文件上传到github上面去，需要用到工具———Git。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><p>windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version来查看一下版本验证是否安装成功。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p>windows:下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功</p><p>配置环境变量：</p><p>1.增加系统变量可以教’NODE_HOME’，值为nodejs所在文件的地方。</p><p>2.在Win10的用户变量，Path变量中增加两个’%NODE_HOME%\node_cache’和’%NODE_HOME%\node_global’,node_cache、node_global文件自行创建，即可完成。</p><p>添加国内镜像源：<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\MyBlog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。</p><p>定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完后输入hexo -v验证是否安装成功。</p><p>至此hexo就安装完了。</p><p>接下来初始化一下hexo,即初始化我们的网站，进入我们主题根目录Hexo，输入hexo init初始化文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹Hexo目录下有：<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>config.yml: 博客的配置文件</p><p>Hexo常用命令详解<br>$ hexo init 命令用于初始化一个本地文件夹为网站的根目录</p><p>$ hexo generate 可以简写成 hexo g<br>该命令用于生成静态文件</p><p>$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s<br>可以加一些参数<br>-p    选项，指定服务器端口，默认为 4000<br>-i    选项，指定服务器 IP 地址，默认为 0.0.0.0<br>-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p><p>$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d</p><p>$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令</p><h3 id="注册Github账号创建个人仓库"><a href="#注册Github账号创建个人仓库" class="headerlink" title="注册Github账号创建个人仓库"></a>注册Github账号创建个人仓库</h3><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository</p><p>要创建一个和你用户名相同的仓库，后面加.<a href="http://github.io,只有这样,将来要部署到github/">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io,其中xxx就是你注册github的用户名./">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。</a></p><h3 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h3><p>生成SSH添加到GitHub，连接Github与本地。<br>右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。</p><p>在git bash输入ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a></p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/navyliky/navyliky.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<a href="http://navyliky.github.io/">http://navyliky.github.io</a> 这个网站看到你的博客了</p>]]></content>
    
    
    <summary type="html">简短的自我介绍</summary>
    
    
    
    <category term="个人" scheme="https://navyliky.github.io.git/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="个人介绍" scheme="https://navyliky.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
