<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Navy的荒岛</title>
  
  <subtitle>世界既不黑也不白，而是一道精致的灰</subtitle>
  <link href="https://navyliky.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://navyliky.github.io.git/"/>
  <updated>2024-07-04T13:52:50.326Z</updated>
  <id>https://navyliky.github.io.git/</id>
  
  <author>
    <name>Navy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>指针函数和函数指针</title>
    <link href="https://navyliky.github.io.git/2024/07/04/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B91/"/>
    <id>https://navyliky.github.io.git/2024/07/04/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%9F%A5%E8%AF%86%E7%82%B91/</id>
    <published>2024-07-04T13:40:00.000Z</published>
    <updated>2024-07-04T13:52:50.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁而无比强烈的激情支配着我的一生。<br>——《我为什么而活着》罗素 （哲学家 数学家 思想家）</p></blockquote><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>顾名思义，它的本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret *<span class="title function_">func</span><span class="params">(args, ...)</span>;</span><br></pre></td></tr></table></figure><p>其中，func是一个函数，args是形参列表，ret *作为一个整体，是 func函数的返回值，是一个指针的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">func_sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error:n must be &gt; 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input one number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="type">int</span> *p = func_sum(num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum:%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码使用普通的局部变量来实现，也是可以的，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_sum2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error:n must be &gt; 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input one number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="type">int</span> ret = func_sum2(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum2:%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的<strong>局部变量</strong>是存放于<em><strong>栈区</strong></em>的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。上面的示例中，在返回该指针后，立即访问，的确是得到了正确的结果，但这只是十分巧合的情况，如果我们等待一会儿再去访问该地址，很有可能该地址已经被其他的变量所占用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。<br><em><strong>因此，在使用指针函数的时候，一定要避免出现返回局部变量指针的情况。 ***<br>那么为什么用了static就可以避免这个问题呢？<br>原因是一旦使用了static去修饰变量，那么该变量就变成了静态变量。而</strong>静态变量</em><em>是存放在</em><strong>数据段</strong>*的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。<br>因此，还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。<br>我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。<br>其声明形式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret (*p)(args, ...);</span><br></pre></td></tr></table></figure><p>其中，ret为返回值，<strong>p作为一个整体，代表的是指向该函数的指针，args为形参列表。其中p被称为函数指针变量。</strong><br>关于函数指针的初始化<br>与数组类似，在数组中，数组名即代表着该数组的首地址，函数也是一样，函数名即是该数组的入口地址，因此，函数名就是该函数的函数指针。<br>因此，我们可以采用如下的初始化方式：<br>函数指针变量 &#x3D;  函数名; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">//函数指针的定义</span></span><br><span class="line">    <span class="comment">//int (*p)();       //函数指针的另一种定义方式，不过不建议使用</span></span><br><span class="line">    <span class="comment">//int (*p)(int a, int b);   //也可以使用这种方式定义函数指针</span></span><br><span class="line">    </span><br><span class="line">    p = max;    <span class="comment">//函数指针初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = p(<span class="number">10</span>, <span class="number">15</span>);    <span class="comment">//函数指针的调用</span></span><br><span class="line">    <span class="comment">//int ret = (*max)(10,15);</span></span><br><span class="line">    <span class="comment">//int ret = (*p)(10,15);</span></span><br><span class="line">    <span class="comment">//以上两种写法与第一种写法是等价的，不过建议使用第一种方式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d \n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要使用函数指针？"><a href="#为什么要使用函数指针？" class="headerlink" title="为什么要使用函数指针？"></a>为什么要使用函数指针？</h3><p>那么，有不少人就觉得，本来很简单的函数调用，搞那么复杂干什么？其实在这样比较简单的代码实现中不容易看出来，当项目比较大，代码变得复杂了以后，函数指针就体现出了其优越性。<br>举个例子，如果我们要实现数组的排序，我们知道，常用的数组排序方法有很多种，比如快排，插入排序，冒泡排序，选择排序等，如果不管内部实现，你会发现，除了函数名不一样之外，返回值，包括函数入参都是相同的，这时候如果要调用不同的排序方法，就可以使用指针函数来实现，我们只需要修改函数指针初始化的地方，而不需要去修改每个调用的地方（特别是当调用特别频繁的时候）。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针的一个非常典型的应用就是回调函数。<br>什么是回调函数？<br>回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。<br>回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。<br>同样我们来看一个回调函数的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：实现累加求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func_sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;n must be &gt; 0\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是回调函数，其中第二个参数为一个函数指针，通过该函数指针来调用求和函数，并把结果返回给主调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> (*p)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> p(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the sum from 0 to %d is %d\n&quot;</span>, n, callback(n, func_sum));       <span class="comment">//此处直接调用回调函数，而不是直接调用func_sum函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>IPC</title>
    <link href="https://navyliky.github.io.git/2024/07/02/%E4%BB%8B%E7%BB%8D/IPC/"/>
    <id>https://navyliky.github.io.git/2024/07/02/%E4%BB%8B%E7%BB%8D/IPC/</id>
    <published>2024-07-02T12:13:00.000Z</published>
    <updated>2024-07-02T11:42:16.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我每天都自问：＂如果今天是我生命的最后一天，我还会做今天要做的事情吗？＂<br>如果连续很多天得到【否定】的回答，那我就需要作出一些改变了。<br>——乔布斯</p></blockquote><p>Inter process communication —&gt; 进程间通信<br>实质：信息的交换</p><h2 id="为什么需要进程间通信"><a href="#为什么需要进程间通信" class="headerlink" title="为什么需要进程间通信"></a>为什么需要进程间通信</h2><p>1).数据传输</p><p>一个进程需要将它的数据发送给另一个进程。</p><p>2).资源共享</p><p>多个进程之间共享同样的资源。</p><p>3).通知事件</p><p>一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。</p><p>4).进程控制</p><p>有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</p><h2 id="什么是进程间通信"><a href="#什么是进程间通信" class="headerlink" title="什么是进程间通信"></a>什么是进程间通信</h2><p>进程隔离：<br>       进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。<br>虚拟地址空间：<br>        就32位系统而言，当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从 0x00000000~0xFFFFFFFF ，最大值 0xFFFFFFFF 表示的即为 4GB 大小的容量。4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。<br>        针对 Linux 操作系统，将最高的1G字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF ）供内核使用，称为内核空间，而较低的 3G 字节（从虚拟地址 0x00000000 到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程都可以通过系统调用进入到内核。其中在 Linux 系统中，进程的用户空间是独立的，而内核空间是共有的，进程切换时，用户空间切换，内核空间不变。</p><h2 id="IPC通信原理"><a href="#IPC通信原理" class="headerlink" title="IPC通信原理"></a>IPC通信原理</h2><p> 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信机制。通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，内核空间调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的用户空间内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>  IPC的方式通常有linux下的 管道（Streams)（包括无名管道和命名管道）、消息队列、信号量、信号、共享存储、Socket等。其中 Socket和Streams支持不同主机上的两个进程IPC，以及android下的Binder。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。<br>pipe(无名管道)特点：<br>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。<br>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。<br>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，调用pipe函数 在内核中开辟一块缓冲区用于通信，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>],n;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">pipe(fd);<span class="comment">//创建一个无名管道</span></span><br><span class="line"></span><br><span class="line">pid=fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);<span class="comment">//关闭读描述符</span></span><br><span class="line">write(fd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">n=read(fd[<span class="number">0</span>],buf,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i have receive %d words:buf is %s\n&quot;</span>,n,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>FIFO，也称为命名管道，它是一种文件类型<br>特点:<br>FIFO可以在无关的进程之间交换数据，与无名管道不同。<br>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I&#x2F;O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：</p><blockquote><p>若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p></blockquote><blockquote><p>若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd_r,fd_w;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">fd_w=open(<span class="string">&quot;/tmp/fifo1&quot;</span>,O_RDWR);</span><br><span class="line">fd_w=open(<span class="string">&quot;/tmp/fifo2&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line">pid=fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(fd_r,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">write(fd_w,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是一种事件通知机制，当接收到该信号的进程会执行相应的操作。<br>特点:</p><ul><li><p>由硬件产生，如从键盘输入Ctrl+C可以终止当前进程</p></li><li><p>由其他进程发送，例如，在shell进程下，使用命令kill  -信号值 PID</p></li><li><p>异常，当进程异常时发送信号</p></li></ul><p>信号是由操作系统处理的，所以信号的处理在内核态。如果不是紧急信号的话，它不一定被立即处理，操作系统不会为了处理一个信号而把当前正在运行的进程挂起，因为挂起（进程切换）当前进程消耗很大。所以操作系统一般会将信号先放入信号表中，一般选择在内核态切换回用户态的时候处理信号（不用自己单独进行进程切换以免浪费时间）</p>]]></content>
    
    
    <summary type="html">进程间通信</summary>
    
    
    
    <category term="IPC" scheme="https://navyliky.github.io.git/categories/IPC/"/>
    
    
    <category term="IPC" scheme="https://navyliky.github.io.git/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>静态查找</title>
    <link href="https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/"/>
    <id>https://navyliky.github.io.git/2024/06/29/%E4%BB%8B%E7%BB%8D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/</id>
    <published>2024-06-29T13:40:00.000Z</published>
    <updated>2024-06-29T14:51:29.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不要去欺骗别人——因为你能骗到的，都是相信你的人</p></blockquote><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p> 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；而是查找失败。</p><p> 查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种：</p><p>1.查询某个特定的数据元素是否在查找表中；</p><p>2.检索满足条件的某个特定的数据元素的各种属性；</p><p>3.在查找表中插入一个数据元素；</p><p>4.从查找表中删除某个数据元素；</p><p>静态查找表：若一个查找表的操作只涉及上述操作的1和2，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态的插入或删除的查找表称为动态查找表。适合静态查找表的的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和B树都是二叉排序树的改进。</p><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中 “学号” 这一数据项的值唯一地标识一名学生。</p><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p> 顺序查找又称为线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过 next 指针来依次扫描每个元素。顺序查找通常分为对一般的<strong>无序线性表</strong>的顺序查找和对按<strong>关键字有序</strong>的线性表的顺序查找。</p><h4 id="线性表的顺序查找"><a href="#线性表的顺序查找" class="headerlink" title="线性表的顺序查找"></a>线性表的顺序查找</h4><p> 这里是无序线性表的顺序查找，基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]==key)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">a[<span class="number">0</span>]=key;</span><br><span class="line">i=n;</span><br><span class="line"><span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环的时候，我们都要判断i是否小于等于n，也就是无哨兵，这里就浪费了效率，所以我们就设置了一个哨兵，通常都是数组的第一个元素，将key赋值给它，然后i就从最大的开始每次都-1，这里就不需要再判断了，因为就算没有找到，循环遇到数组的第一个元素也会跳出，这里就会提高一些效率。</p><p>查找最好的情况就是第一次就找到了，时间复杂度为O(1),最坏的情况是直到最后一个才找到，时间复杂度为O(n),取平均情况就为O((n+1)&#x2F;2),所以这个算法的最终时间复杂度就为O(n)。</p><h4 id="线性表的折半查找"><a href="#线性表的折半查找" class="headerlink" title="线性表的折半查找"></a>线性表的折半查找</h4><p>这里是有序的线性表查找，基本思想是首先将给定值 key 与表中<em><strong>中间位置</strong></em>的元素进行比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;<span class="comment">/* 折半 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以把它看作是具有n个节点的完全二叉树，深度就为log2(n)+1,最好的情况就是第一次就找到了，最坏的情况跟这颗二叉树的深度有关，所以这个算法的时间复杂度就为logn,相比较于顺序查找，效率还是快很多。</p><h4 id="线性表的插值查找"><a href="#线性表的插值查找" class="headerlink" title="线性表的插值查找"></a>线性表的插值查找</h4><p>我们在查字典时，如果需要查找的是cook，就会从前面开始翻找，如果查找的是zoo，就会从后面开始翻找，所以对折半查找进行优化，我们不必每次都从中间开始找，而是按照比例（c字母在26个字母是前三个，假如这个字典，是2600页，那么你要查找的区间大概率为前三百页），当然这个算法只用于比较均匀的数据（说了是大概率），如果不均匀，那么这个算法就毫无优势。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Interpolation_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性表的斐波那契查找"><a href="#线性表的斐波那契查找" class="headerlink" title="线性表的斐波那契查找"></a>线性表的斐波那契查找</h4><p>基本思想 这个想法是首先找到大于或等于给定数组长度的最小斐波那契数。令找到的斐波那契数为 fib（第 m 个斐波那契数）。我们使用第 (m-2) 个斐波那契数作为索引（如果它是有效索引）。设第(m-2)个斐波那契数为i，我们将arr[i]与x进行比较，如果x相同，则返回i。否则，如果 x 更大，则对 i 之后的子数组进行递归，否则对 i 之前的子数组进行递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">a[i]=a[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">k=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">k=k<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://navyliky.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>组播广播</title>
    <link href="https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/"/>
    <id>https://navyliky.github.io.git/2024/03/22/%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E6%92%AD%E5%B9%BF%E6%92%AD/</id>
    <published>2024-03-22T13:40:00.000Z</published>
    <updated>2024-06-29T14:51:39.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果说调试（debug）是去除 bug 的过程，那么编程就是制造 bug 的过程。<br>——Edsger Dijkstra （图灵奖得主）</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 三种IP地址：单播地址、广播地址和组播地址。广播和多播仅应用于UDP（因为TCP是端对端的连接，无法实现一对多）。</p><p>单播，一对一，目的地址是单个主机；</p><p>广播，一对全部，目的地址是局域网中的全部主机；</p><p>多播，一对部分，目的地址是局域网中的部分主机；广播也是多播的一种特殊形式，即目的地址为全部主机。</p><p>TCP是一个面向连接的协议，TCP一定是点对点的，一点是两个主机来建立连接的，TCP肯定是单播。只有UDP才会使用广播和组播。</p><p>有时一个主机要向网上的所有其它主机发送帧，这就是广播，广播分为二层广播（目的MAC全F）和三层广播（IP地址的主机位全1），二层广播是不能跨路由器的，三层广播是可以跨路由器路由的。</p><p>多播属于单播和广播之间，帧仅传送给属于多播组的多个主机。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播的例子随处可见，比如说把屏幕共享给很多人，其实也是广播，首先把屏幕截图，然后广播给所有的客户端，比如说屏幕共享软件，一般都有一个广播地址，只要在同一个网段的客户端都能收到广播，如果设置广播地址为255.255.255.255，那么不管哪个网段都能收到广播。屏幕共享软件会把当前屏幕截图并分为很多小块，然后压缩，广播给所有客户端，客户端再进行解压。</p><p> 广播地址：<br>子网广播地址：x.x.x.255 (主机号全部为1)的地址，我们称为广播地址</p><p>192.168.31.105<br>255.255.255.0<br>网段号 &#x3D; IP &amp; netmask &#x3D; 192.168.31<br>广播地址： 192.168.31.255<br>255.255.255.255 全网广播地址<br>很多路由器设置：禁止全网广播<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》很有可能造成网络风暴<br>广播的工作过程：<br>广播发送者：<br>socket<br>使能广播功能 setsockopt<br>sendto<br>广播接收者：<br>socket<br>使能广播功能 setsockopt<br>bind x.x.x.255 + 端口号<br>recvfrom</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">broadcast_onoff</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (<span class="type">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt SO_BOARDCAST error:&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h2><p>(1) 多播也只有对传输协议为 UDP才支持<br>(2) 多播地址 IP地址 D类地址<br>224.0.0.0 —- 239.255.255.255<br>(3) 广播式发送，占用大量的带宽，造成广播风暴<br>多播是一种折中方式，只有加入 某个多播组才能收到信息<br>（4） 多播编程思路：<br>多播发送者：<br>socket<br>sendto : D类地址 + 端口号<br>……<br>recvfrom<br>多播接收者：<br>socket<br>加入多播组<br>bind: D类地址+port<br>recvfrom<br>如何加入多播组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line">inet_aton(<span class="string">&quot;224.0.0.1&quot;</span>, &amp;mreq.imr_multiaddr); <span class="comment">//D类地址</span></span><br><span class="line">mreq.imr_interface.s_addr = INADDR_ANY; <span class="comment">//由内核找个合适网卡IP</span></span><br><span class="line"><span class="comment">//加入多播组：</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="type">void</span> *)&amp;mreq, sizeo</span><br><span class="line">f(mreq));</span><br></pre></td></tr></table></figure><p>struct ip_mreq {<br>struct in_addr imr_multiaddr; &#x2F;* IP multicast address of<br>group <em>&#x2F;<br>struct in_addr imr_interface; &#x2F;</em> local IP address of<br>interface *&#x2F;<br>};<br>imr_multiaddr： 多播组地址，D类地址，逻辑上的组号，用来<br>区分不同的多播组，<br>但是这个逻辑上的地址，在真正收发数据的时<br>候，一定要依赖真正的网卡<br>这种接口<br>imr_interface： 接口地址</p>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://navyliky.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(二)</title>
    <link href="https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/"/>
    <id>https://navyliky.github.io.git/2024/01/28/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%802/</id>
    <published>2024-01-28T13:40:00.000Z</published>
    <updated>2024-07-02T05:13:17.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>许多人所谓的成熟，不过是被习俗磨去了棱角，变得世故而实际了；那不是成熟，而是精神的早衰和个性的夭亡！<br>真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。<br>——《在世纪的转折点上》尼采 （哲学家 思想家）</p></blockquote><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>1） for 语句语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号的内容是用来描述控制循环的变量的变化过程。</p><ol><li>循环变量的初始化 i&#x3D;1；</li><li>循环结束的条件(逻辑表达式，为真继续循环，为假结束循环) i&lt;100;</li><li>每次循环对循环变量的操作 i++</li><li>要循环的语句<br>他是按照这个顺序执行： {1,2},{4,3,2},{4,3,2},{4,3,2},,{4,3,2},{4,3,2},<br>正常情况下(没有break)： 正常结束<br>continue; 在循环中碰到这个continue,跳过下面的语句，重新开始下一次循环<br>循环嵌套——- 有多层循环</li></ol>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础(一)</title>
    <link href="https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/"/>
    <id>https://navyliky.github.io.git/2024/01/27/%E4%BB%8B%E7%BB%8D/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%801/</id>
    <published>2024-01-27T13:40:00.000Z</published>
    <updated>2024-07-02T05:13:12.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最多人走的路肯定最安全<br>但别指望会在这样的路上碰到很多猎物<br>——纪德 （作家 诺贝尔奖得主)</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者将把C语言的知识要点，学习心得以博客形式发表，希望通过这种形式督促自身的学习，也能在这里与大家共同进步，早日成为大牛！</p><p>本系列（初始C语言）只是简单介绍每个知识点、C语言的基础知识，意在使读者（还有自己）大概了解C语言。</p><h2 id="初始C语言"><a href="#初始C语言" class="headerlink" title="初始C语言"></a>初始C语言</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//字符数据类型//就是不是数字的字符</span></span><br><span class="line"><span class="type">short</span><span class="comment">//短整型//就是数字小（绝对值）的整数，很少用</span></span><br><span class="line"><span class="type">int</span> <span class="comment">//整型//就是整数</span></span><br><span class="line"><span class="type">long</span><span class="comment">//长整型//就是数字（绝对值）大的整数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span><span class="comment">//更长的整型//很少用</span></span><br><span class="line"><span class="type">float</span><span class="comment">//单精度浮点数//就是小数</span></span><br><span class="line"><span class="type">double</span><span class="comment">//双精度浮点数//小数位数多的小数</span></span><br></pre></td></tr></table></figure><p>分这么多数据类型的原因：不同数据类型在内存中所占大小是不一样的，如果用大小的盒子装蛋糕，蛋糕有大有小，难免造成空间的浪费，所以人们规定了不同的数据类型，以便空间被物尽其用。</p><h3 id="字符类型—char"><a href="#字符类型—char" class="headerlink" title="字符类型—char"></a>字符类型—char</h3><p>字符类型是一种数据类型，包含256个不同的字符数据,字符数据类型的范围是 -128 - 127(-2^7—2^7-1)<br>在内存中占一个字节（Byte）,在C语言中要使用单引号包含起来，’a’ ‘1’ ‘+’,它也是一个关键字，字符数据也可以用数字表示，字符数据有两种的身份，字符身份和数字身份，字符身份和数字身份的对应关系由ASCII码表定义：<br>man ascii ———- 查看ascii表<br>‘a’ ————– 97<br>‘1’ ————– 49<br>‘+’ ————— 43<br><strong>BIN</strong>: 2进制 ， 只有0和1，两种数组的数据，计算机只认识二进制： 逢2进1。<br>101010 —&gt; 2^5+2^3+2^1 &#x3D; 32+8+2 &#x3D; 42<br><strong>OCT</strong> : 8进制 ， 是以0开头的，逢8进1。<br>027 —-&gt; 2<em>8+7 &#x3D; 23<br>0123 —-&gt; 1</em>8^2+2<em>8^1 + 3</em>8^0 &#x3D; 64 + 16 + 3 &#x3D; 83<br>使用占位符%o将数字的8进制形式打印出来<br><strong>DEC</strong>：10进制<br><strong>HEX</strong>： 16进制 : 0x 开头表示 16进制 ,逢16进1<br>0x27 —-&gt; 2<em>16^1 + 7</em>16^0 &#x3D; 32+7 &#x3D; 39<br>0x123 —&gt;1<em>16^2+2</em>16^1 + 3 *16^0 &#x3D; 256 + 32 + 3 &#x3D;291<br>使用占位符%x %X打印数字的16进制形式<br>十进制 转换为 二进制 ： 134<br>方法1：<br>把十进制数字拆分成多个2的整数次方之和，然后把每个拆分结果单独转换成二进制，随后把所有的结果合并<br>179 &#x3D; 128 + 32 + 16 + 2 + 1<br>&#x3D; 2^7 + 2^5 + 2^4 + 2^1 + 2^0<br>&#x3D; 10110011<br>方法2：把十进制数组不停地除以2直到结果为0，然后把所有的余数倒着写就是对应的二进制数<br>134 0<br>67 1<br>33 1<br>16 0<br>8 0<br>4 0<br>2 0<br>1 1<br>0<br>10000110<br>使用以上方法得到的是对应数字二进制的 <em><strong>原码</strong></em><br>计算机中实际上保存的是二进制的 <em><strong>补码</strong></em><br>所有非负数的补码就是原码 134 –&gt; （原码，补码 ）<br>10000110<br><strong>负数的补码等于原码取反加1</strong> ： -6<br>-6 ： 1000000000000000000000000000110 —</p><blockquote><p>11111111111111111111111010<br>计算机保存有符号的数据时，最高位是符号位，0表示正数，1表示负数<br>使用printf打印字符变量时，使用%d打印数字，使用%c打印字符<br>0-127范围内字符身份和数字身份的对应关系是固定的，所有的计算机都一样<br>‘\n’ —————– 换行符<br>‘\r’ —————– 移动光标到行首<br>‘\t’—————— 制表符<br>‘\b’—————— 退格键<br>‘ “ \在打印时需要转义 —————- &quot; &#39; \<br>ascii表中，数字，大写字母，小写字母是连续的<br>‘b’ - ‘a’ &#x3D; ‘B’ - ‘A’<br>‘g’ - ‘d’ &#x3D; ‘3’ - ‘0</p></blockquote><h3 id="字符类型—无符号字符类型-没有负数-unsigned-char"><a href="#字符类型—无符号字符类型-没有负数-unsigned-char" class="headerlink" title="字符类型—无符号字符类型 (没有负数) unsigned char"></a>字符类型—无符号字符类型 (没有负数) unsigned char</h3><p>范围0-255，同样包含256个不同的字符<br>其他性质和char类型相同</p><h3 id="字符类型—短整型-short-int"><a href="#字符类型—短整型-short-int" class="headerlink" title="字符类型—短整型 short int"></a>字符类型—短整型 short int</h3><p>16位： 2^16次方,短整型包含65536个不同的整数，范围从-32768 - 32767<br>类型名short,占用内存2个字节<br>对应的占位符是%hd —-&gt; half d</p><h3 id="字符类型—整型-int"><a href="#字符类型—整型-int" class="headerlink" title="字符类型—整型 int"></a>字符类型—整型 int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名int,占用内存4个字节<br>对应的占位符%d</p><h3 id="字符类型—无符号整型-unsigned-int"><a href="#字符类型—无符号整型-unsigned-int" class="headerlink" title="字符类型—无符号整型 unsigned int"></a>字符类型—无符号整型 unsigned int</h3><p>范围 0 - 2^32-1<br>占位符%u<br>注:类型名中int可以省略<br>其他性质和int相同</p><h3 id="字符类型—长整型-long-long-int"><a href="#字符类型—长整型-long-long-int" class="headerlink" title="字符类型—长整型 long&#x2F;long int"></a>字符类型—长整型 long&#x2F;long int</h3><p>包含2^32个整数，范围从-2^31 - 2^31-1<br>类型名long,占用内存4个字节<br>对应的占位符%ld</p><h3 id="字符类型—无符号长整型-unsigned-long-unsigned-long-int"><a href="#字符类型—无符号长整型-unsigned-long-unsigned-long-int" class="headerlink" title="字符类型—无符号长整型 unsigned long&#x2F;unsigned long int"></a>字符类型—无符号长整型 unsigned long&#x2F;unsigned long int</h3><p>范围 0 - 2^32-1<br>占位符%lu<br>h—-&gt; half<br>u—-&gt; usigned<br>l —–&gt;long<br>d—–&gt; int</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>计算机使用浮点类型来记录带小数点的数字，浮点类型分为两<br>种：<em><strong>单精度浮点型和双精度浮点型</strong></em><br>单精度浮点型对应的类型名是float,占用4个字节<br>占位符：%f %g (%g不保留小数点后的0)<br>双精度浮点型对应的类型名是double，占用8个字节<br>占位符：%lf %lg<br>计算机中的整数默认是int型，可以在数字后加u表示该数字是无<br>符号整型，比如:8u<br>计算机中的小数默认是double型，可以在数字后加f表示该数字<br>是单精度浮点型，比如：4.1f<br>注：可以使用sizeof获取类型，变量，数字的大小</p>]]></content>
    
    
    <summary type="html">C语言基础知识点</summary>
    
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://navyliky.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>个人介绍</title>
    <link href="https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    <id>https://navyliky.github.io.git/2024/01/24/%E4%BB%8B%E7%BB%8D/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-01-24T12:13:00.000Z</published>
    <updated>2024-06-29T14:52:16.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人的一切痛苦都是源于对自己无能的愤怒<br>——王小波 （作家）</p></blockquote><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我叫王行杭，英文名navy（在百度上搜索关于颜色的英文当中随便选的一个单词，也作为我最喜欢的单词之一）。对于自己的介绍，实在无病呻吟啰嗦很多，作为芸芸众生的其中之一，没有太值得炫耀的东西，但总的来说，也不算太糟糕。</p><h2 id="喜欢的运动"><a href="#喜欢的运动" class="headerlink" title="喜欢的运动"></a>喜欢的运动</h2><p>小学一直热爱的乒乓球，当时我们学校一共就几个乒乓球桌，为了占位置，可以中饭都不去吃。从初中开始，喜欢上了篮球，直到高一，还参加我们篮球校队的培训，但本人身体天分实在有限。大三又开始天天打台球，看斯诺克</p><h2 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h2><p>本博客基于Hexo，所以首先要了解一下我们搭建博客所要用到的框架。Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到github或者coding等代码管理托管平台，然后别人就可以浏览你的博客网页啦。</p><p>关于做这个博客的目的，我也并不是很清楚，当初就看到了几个大佬的博客，觉得很酷，就在网上看各种教程，最终东拼西凑，成了这个样子，做完之后好像也没写啥东西（我好像就这样，三分钟热情），但时隔几个月，发现这个也能成自己面试时的一个自我介绍的加分项吧，所以写写东西，也算对自己学的东西的总结。</p><h2 id="博客流程"><a href="#博客流程" class="headerlink" title="博客流程"></a>博客流程</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>为了把本地的网页文件上传到github上面去，需要用到工具———Git。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><p>windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version来查看一下版本验证是否安装成功。</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p>windows:下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功</p><p>配置环境变量：</p><p>1.增加系统变量可以教’NODE_HOME’，值为nodejs所在文件的地方。</p><p>2.在Win10的用户变量，Path变量中增加两个’%NODE_HOME%\node_cache’和’%NODE_HOME%\node_global’,node_cache、node_global文件自行创建，即可完成。</p><p>添加国内镜像源：<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\MyBlog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。</p><p>定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完后输入hexo -v验证是否安装成功。</p><p>至此hexo就安装完了。</p><p>接下来初始化一下hexo,即初始化我们的网站，进入我们主题根目录Hexo，输入hexo init初始化文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹Hexo目录下有：<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>config.yml: 博客的配置文件</p><p>Hexo常用命令详解<br>$ hexo init 命令用于初始化一个本地文件夹为网站的根目录</p><p>$ hexo generate 可以简写成 hexo g<br>该命令用于生成静态文件</p><p>$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s<br>可以加一些参数<br>-p    选项，指定服务器端口，默认为 4000<br>-i    选项，指定服务器 IP 地址，默认为 0.0.0.0<br>-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p><p>$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d</p><p>$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令</p><h3 id="注册Github账号创建个人仓库"><a href="#注册Github账号创建个人仓库" class="headerlink" title="注册Github账号创建个人仓库"></a>注册Github账号创建个人仓库</h3><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository</p><p>要创建一个和你用户名相同的仓库，后面加.<a href="http://github.io,只有这样,将来要部署到github/">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io,其中xxx就是你注册github的用户名./">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。</a></p><h3 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h3><p>生成SSH添加到GitHub，连接Github与本地。<br>右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。</p><p>在git bash输入ssh -T <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a></p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/navyliky/navyliky.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<a href="http://navyliky.github.io/">http://navyliky.github.io</a> 这个网站看到你的博客了</p>]]></content>
    
    
    <summary type="html">简短的自我介绍</summary>
    
    
    
    <category term="个人" scheme="https://navyliky.github.io.git/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="个人介绍" scheme="https://navyliky.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
